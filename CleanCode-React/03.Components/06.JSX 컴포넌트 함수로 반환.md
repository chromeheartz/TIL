## Rendering

### 06. JSX 컴포넌트 함수로 반환

---

```jsx
// JSX 컴포넌트 함수로 반환
return (
  <div>
    {/* 어떤 형태가 맞을까? */}
    {TopRender()}
    <TopRender />
    {renderMain({})}
  </div>
);
```

### 📌 예제 1

```jsx
const ReturnJSXFunction = () => {
  const TopRender = () => {
    return (
      <header>
        <h1>Clean Code JavaScript</h1>
      </header>
    );
  };

  return <>{TopRender()}</>;
};
```

간혹 이렇게 컴포넌트 안에 `함수를 반환` 해서 컴포넌트를 렌더링 하는 경우가 있다. 아주 잘 동작하기 때문에 이상함을 못느낄 수도 있다. 표현식으로 해서 다양한 함수를 때려 넣거나 아니면 `jsx` 들을 `redux / store` 같은 곳에 저장하거나 `util` 함수에 넣어서 응용해서 사용하는 경우가 분명히 있다.

✅ 하지만 일반적인 생태계 입장에서 보았을 때 문제가 생길 수 있다.

- `scope` 가 꼬일 수 있다.
- `redux / routing` 등 유틸함수에서도 쓸 수 있기 때문에 언제 어떻게 쓰일지 모른다.

> 애초에 `jsx` 만 쓰게하고 `.js` 를 컴파일 돌릴 때 걸러내지 못한다면 `치명적인 이슈` 를 만들어낼 수 있다.

또한 `<TopRender />` 만 보면 누가 보아도 컴포넌트임을 알 수 있지만 `{TopRender()}` 로 작성을 한다면 연산된 값이 렌더링 될때마다 반환되는 것인지 문자열인지 알기가 어렵다.

현재는 `컴포넌트 내부` 에 있다고 가정했기 때문에 알아보기 쉬운 것일 뿐. 또한 `props` 를 넘기기 까다롭다

#### 그럼 이런 패러다임은 정상적인 패턴일까?

라이브러리 같은 것을 이용한 서드파티를 활용하는 것이 아니라면 `굳이` 내부적인 프로젝트에서 이러한 `트릭 함수` 를 만들 이유는 없다.

### 📌 정리

> ✅ 이런 `JSX` 형태도 리액트에서 렌더링이 되긴 하지만 특별한 이유가 없다면 컴포넌트는 조금 더 명시적으로 컴포넌트임을 알 수 있도록 `props` 를 넘길 수 있는 형태로 작성하는 것이 좋다.
