## 쿼리 생성 및 로딩/에러 상태
### 07. staleTime vs cacheTime
---------------------------------------------

### 📌 Stale Data

`React Query` 에서 데이터가 만료되었다는 것은 무슨 뜻일까?
`데이터 리패칭(Refetching)` 은 만료된 데이터에서만 실행된다. 데이터 리패칭 실행에는 만료된 데이터 외에도 여러 트리거가 있다. 예로, 컴포넌트가 다시 마운트되거나 윈도우가 포커스 되었을 때가 있다.

⭐️ 단, 만료된 데이터일 경우에만 `리패칭` 이 실행된다.

✅ `staleTime` 은 데이터를 허용하는 `최대 나이` 라고 할 수 있다. 
달리 말하면 데이터가 만료됐다고 판단하기 전까지 `허용하는 시간` 이다.

업데이트 하는 방법은 `useQuery` 를 호출할 때 `세 번째 인수` 를 추가하는 것이며 이는 `옵션` 이다.
`1/1000초 단위로 지정`

```jsx
// Posts.jsx

// 2초마다 만료되도록 설정
const { data, isError, error, isLoading } = useQuery("posts", fetchPosts, { staleTime: 2000});
```

이렇게 지정하면 윈도우가 다시 포커스 될 때 `fresh` 상태에서 2초 후에 `stale` 상태로 변경되는 것을 확인 할 수 있다.
보통은 `리패칭이 실행될 경우` 라도 데이터가 만료되지 않으면 리패칭은 실행되지 않는다.
`데이터가 만료된 경우` 에만 실행된다.

![스크린샷 2023-08-06 오후 11 36 21](https://github.com/chromeheartz/TIL/assets/95161113/05f807d9-c4f1-4cb0-a509-7752af97a60c)

### 📌 staleTime의 기본값은 왜 0일까?

`React Query 개발자` 의 트윗을 확인해보면 그 답을 알 수 있다.
`업데이트가 왜 안되죠?` 보다 `데이터가 어떻게 늘 최신 상태를 유지하나요?` 가 훨씬 더 나은 질문이다.

⭐️ staleTime의 기본값을 `0` 으로 설정했다는 것은 데이터는 `항상 만료 상태` 이므로 서버에서 `다시 가져와야 한다` 고 가정한다는 뜻이다. 그러면 실수로 클라이언트에게 `만료된 데이터` 를 제공할 가능성이 훨씬 줄어든다.

![스크린샷 2023-08-06 오후 11 37 58](https://github.com/chromeheartz/TIL/assets/95161113/a5fe82ed-8bbb-4c53-a2fe-a4050032e6e5)

### 📌 staleTime vs cacheTime

#### staleTime

`staleTime` 은 리패칭할때의 고려 사항이다.

#### cacheTime

`cache` 나중에 다시 `필요할 수도 있는` 데이터 용이다.
- 특정 쿼리에 대한 `활성 useQuery` 가 없는 경우 해당 데이터는 `cold storage` 로 이동한다.
[`cold storage란?`]
- 구성된 `cacheTime` 이 지나면 캐시의 데이터가 만료되며 유효 시간의 `기본값은 5분` 이다.
	- `cacheTime` 이 관찰하는 시간의 양은 특정 쿼리에 대한 `useQuery` 가 `활성화 된 후 경과한 시간` 이다. 페이지에 표시되는 컴포넌트가 `특정 쿼리에 대해 useQuery를 사용한` 시간.
- 캐시가 만료되고 `가비지 컬렉션` 이 실행되고 클라이언트는 데이터를 사용할 수 없다.

데이터가 캐시에 있는 동안에는 `패칭(Fetching)` 에 사용될 수 있다. 데이터 패칭을 중지하지 않으므로 서버의 `최신 데이터`  로 새로고침이 가능하다. 하지만 계속해서 `빈 페이지` 만 보는 경우가 생길 수 있다.
새로운 데이터를 수집하는 동안 `약간 오래된 데이터` 를 표시하는 편이 좋을 수 있다.

⭐️ 만료된 데이터가 위험할 수 있는 애플리케이션의 경우에는 cacheTime을 0으로 설정하면 된다.
    

[`cold storage란?`]: (https://d2.naver.com/helloworld/526125)