## 쿼리 생성 및 로딩/에러 상태
### 01.React Query 소개
---------------------------------------------

`React Query` 는 React 앱의 서버 상태를 관리하는 라이브러리이다.

### 📌 Client State vs Server State

#### Client State

클라이언트 상태란 웹 브라우저 세션과 관련된 모든 정보를 의미한다.
예로, 사용자는 가장 잘 아는 언어로 텍스트를 읽기 위해 언어를 선택하거나
테마를 다크, 라이트로 바꿀 수 있는데, 이것은 서버에서 일어나는 일과는 아무 관련이 없다.
단순히 `사용자의 상태` 를 추적하는 것 뿐이다.

#### Server State

서버 상태는 서버에 저장되지만
클라이언트에 표시하는 데 필요한 데이터이다.
예로, 데이터베이스에 저장하는 블로그 게시물 데이터가 이에 해당한다.

사용자에게 게시물을 표시하기 위해 클라이언트에 이 데이터가 있어야 하지만
데이터는 여러 클라이언트에 표시할 수 있도록 서버에 저장된다.

### 📌 React Query가 해결할 수 있는 문제

React Query는 클라이언트에서 서버 데이터 캐시를 관리한다.
React 코드에 서버 데이터가 필요할 때 
`패치(Fecth) / Axios` 를 사용해 서버로 바로 이동하지 않고 `React Query 캐시` 를 요청한다.
결국 React Query 캐시가 `서버 데이터에 대한 공급원` 이 되는것이다.

React Query의 역할은 
`React Query 클라이언트` 를 어떻게 구성했느냐에 따라 해당 `캐시의 데이터를 유지 / 관리` 하는 것이다.

 ### 📌 데이터를 관리하는 React Query
 
 서버의 새 데이터로 캐시를 업데이트하는 시기를 설정하는 것은 `사용자의 몫` 이다.
 
```js
// React Query 캐시 예시

key: 'blog-posts'
data: [
  1: {
  title: 'React Query',
  tagLine: 'What is this thing?',
  },
  2: {
    title: 'React Query Mutations',
    tagLine: 'Not just for ninja turtles',
  },
]

// 선언형 처리시 필요하다.
staleTime: 30 seconds
```

이 캐시에는 'blog-posts' 라는 키를 할당한 데이터가 있다.
이 `key` 가 데이터가 식별되는 방식이다.

⭐️ 클라이언트 캐시에 있는 이 데이터가 서버의 데이터와 일치하는지 확인해야 하는데
여기에는 두가지 방법이 있다

- `명령형` : 쿼리 클라이언트에 이 데이터를 무효화하고 캐시에 `교체할 새 데이터` 를 서버에서 가져오게 지시하는 것
- `선언형` : `리패치(Refetch)를 트리거하는 조건` 을 구성하는 것. 예로, 브라우저 창이 다시 포커스 되었을 때 처럼. staleTime으로 다시 가져오기를 언제 트리거할지도 구성할 수 있다.

### 📌 서버 상태 관리에 도움이 되는 많은 도구또한 제공

- `Loading / Error States` : 서버에 대한 모든 쿼리의 로딩 및 오류 상태를 유지해주기 때문에 수동으로 할 필요가 없다.
- `Pagination / infinite scroll` : 사용자를 위해 데이터의 `pagination / infinite scroll` 이 필요한 경우 데이터를 조각으로 가져올 수 있는 도구도 제공
- `Prefetching` : 사용자가 언제 데이터를 필요로 할지 예상하여 `프리패치(Prefetch)` 를 수행할 수 있다. 데이터를 미리 가져와서 캐시에 넣으면 사용자에게 데이터가 필요할 때 앱이 `캐시에서 해당 데이터` 를 가져오기 때문에 서버에 연결할 때까지 기다릴 필요가 없다.
- `Mutations` : React Query가 서버에서 `데이터의 변이(Mutations)` 나 업데이트를 관리할 수 있도록 한다
- `De-duplication of requests` : `쿼리는 key로 식별` 되기 때문에 요청을 관리할 수 있고 페이지를 로드하고 해당 페이지의 여러 구성 요소가 동일한 데이터를 요청하는 경우 `쿼리를 한 번에` 보낼 수 있다. 기존 쿼리가 나가는 동안 다른 구성요소가 데이터를 요청하는 경우 `중복 요청을 제거` 할 수 있다.
- `Retry on error` : 서버에서 오류가 발생하는 경우에 대한 `재시도` 를 관리할 수 있다.
- `Callbacks` : 쿼리가 `성공 / 오류` 일 때를 구별해서 조치를 취할 수 있도록 `콜백 전달` 이 가능하다.