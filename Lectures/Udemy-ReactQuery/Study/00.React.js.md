### What is React.JS
---------------------------------------------

![스크린샷 2023-08-08 오후 8 10 47](https://github.com/chromeheartz/TIL/assets/95161113/d6d48dd9-66a5-44e1-989e-8d7c4b399296)

### 📌 React의 등장 배경

웹 브라우저를 통해 응용 소프트웨어의 기능을 이용할 수 있도록 만든 웹 서비스, 즉 `웹 애플리케이션` 이 다양해지기 시작했다. (아마존, 인스타그램 ...)이에 따라 `웹 개발이 복잡` 해지기 시작했으며, `html / css / js` 만으로는 한계가 생기기 시작했다. DOM 조작을 쉽게 해주는 라이브러리 `jQuery` 가 등장하지만, 이또한 `직접 DOM을 조작하는 방식` 에서 벗어나지는 못했다.
따라서, `프론트엔드 개발` 을 좀 더 쉽게 할 수 있는 `프레임 워크 / 라이브러리` 가 필요해지며 그 결과 `앵귤러, 뷰, 리액트` 가 나오고 사용하게 된것이다.

### 📌 React란?

`React` 는 `자바스크립트 라이브러리` 의 하나로 `사용자 인터페이스` 를 만들기 위해 사용된다. `SPA (싱글 페이지 애플리케이션)` 을 위한 사용자 인터페이스 구축하는데 사용된다. `사용자 인터페이스(UI)` 개발에 초점을 맞추고 있으며 `동적인 웹 페이지 개발` 시 사용이 용이하다.

리액트와 같은 `프론트엔드 라이브러리 / 프레임워크` 를 사용하는 가장 큰 이유 중 하나는 `UI를 자동으로 업데이트` 해주기 때문에 `UI를 빠르게 업데이트 할 수 있다는 점` 이다. 리액트는 `가상 돔(Virtual Dom)` 을 통해 재사용이 필요한 기능을 언제든지 필요한 곳에서 호출하며, 반복적인 코드 작성없이 사용할 수 있도록 해준다.

### 📌 프레임워크 vs 라이브러리

#### 프론트엔드 개발을 좀 더 쉽게 하려고 `프레임 워크 / 라이브러리` 가 필요하다고 했는데 이 두 가지의 공통점 / 차이점은 무엇일까?

#### 공통점
- 복잡한 개발을 편리하게 하기 위해서 `미리 작성해서 제공` 해준 코드이다.
- `필요한 기능` 을 미리 만들어서 사용할 수 있는 형태로 제공한다.
- 개발자들은 처음부터 모든것을 다 만드는 것이 아니라 조금 더 편리하게 개발 할 수 있다.

<hr>

#### 차이점

제일 큰 특징으로는 `제어 흐름` 에 대한 주도성이 `누구 / 어디` 에 있는가에 따라 다르다. 
즉, 애플리케이션의 `Flow(흐름)` 을 누가 쥐고있느냐에 달려있다.

📍 프레임워크

- 전체 흐름을 `프레임워크` 스스로가 쥐고 있다.
- 개발자가 작업을 하기 위한 전체적인 `tool` 을 제공한다. 
- 프레임워크가 제공하는 `규칙과 인터페이스` 에 따라 코드를 작성해야 한다.

📍 라이브러리

- 사용자가 `전체적인 흐름` 을 만들며 필요한 라이브러리를 가져와 사용할 수 있다.
- 전체적인 `틀` 이 아닌 하나의 `기능` 만을 도구처럼 제공한다.

⭐️ 다시 말해 `라이브러리` 는 라이브러리를 가져다가 사용하고 호출하는 측에 `전적` 으로 주도성이 있으며 `프레임워크` 는 가져다가 사용한다기보다는 `그 안에 들어가서` 사용한다는 느낌으로 접근할 수 있다.

> ✅ `앵귤러 / 뷰 / 리액트`
- `앵귤러 / 뷰` 는 웹 개발시 필요한 `모든 기능 / 툴` 을 포함하고 있기 때문에 `프레임워크` 라 할수있다.
- `리액트` 는 `ui를 만드는 기능` 만을 제공하기 때문에 `라이브러리` 다.

### 📌 React Concept

리액트는 현재 현업에서 인기 있는 `웹/앱(RN)` 의 `View` 를 개발할 수 있다.

보통 우리가 생각하는 애플리케이션(웹, 앱 혹은 데스크탑용 소프트웨어)을 만들기 위해서는 사용자가 조작하기 위한 `UI(User-Interface)`, UI를 컨트롤하기 위한 `로직` , 데이터를 처리하는 `비지니스 로직` 등 3가지 부분으로 개발이 필요하다.

이렇게 특정 부분을 나누어 개발하는 방법론을 [`MVC패턴`] / [`MVVM패턴`] 이라고 하며, React.js는 View 즉, `사용자가 조작하기 위한 UI` 를 만드는 것을 도와주는 라이브러리이다.

### 📌 Why React? 🧐

- 앵귤러와 뷰는 자신들만의 문법을 갖고 있지만, `리액트` 는 `자바스크립트 기반의 문법` 을 사용하기 대문에 자바스크립트에 익숙하다면 보다 쉽게 사용이 가능하다. `JSX(javascript를 확장한 문법)` 을 사용한다.
- `가볍고 유연한 라이브러리` 로, 필요한 부분에만 적용할 수 있다. 때문에 기존 프로젝트에 리액트를 통합하기 쉽게 만들어준다. 또한, 다른 프레임워크나 라이브러리와의 혼용도 가능하므로 기존 코드를 변경하지 않고도 리액트를 도입할 수 있다.
- `리액트` 는 `Meta(FaceBook)` 에서 개발한 오픈소스 프로젝트로, 활발하고 다양한 `커뮤니티 / 생태계` 를 가지고 있다. 이는 문제 해결을 위한 자료와 지원을 쉽게 얻을 수 있으며, `다양한 라이브러리와 도구` 를 활용하여 `개발 생산성` 을 높일 수 있다.
- `리액트의 UI` 를 만드는 기능을 확장하여 `웹이 아닌 플랫폼` 에 활용할 수 있도록 기술을 확장했다. `React-Native` 는 `Android / IOS의 모바일 앱` 개발을 할 수 있다.

### 📌 React의 특징

- React는 `선언형` 이다. (참고자료 : [`선언형,명령형`])
- `컴포넌트 기반` 으로 `재사용성` 이 뛰어나다.
- `Virtual DOM(가상돔)` 기반으로 가볍다.
- 컴포넌트는 `state / props` 를 가진다.

`선언형(Declarative), 컴포넌트(Component), 재사용성(Reusable), 가상돔(Virtual DOM)` 
이 4가지 키워드가 리액트의 근본이 아닐까.

#### 📍 React - Declarative

소프트웨어  공학에서 자주 접하게 되는 개념은 `패러다임(Paradign)` 이다. 즉, 프로그래밍을 어떻게 할 것인가에 대한 논의가 항상 활발하게 이루어져왔다.

리액트는 `선언형` 성격에 맞게 `컴포넌트(원하는 결과, 뷰)` 를 얻기 위해 `jsx 문법` 을 통해 구현한다. 즉, jsx를 `얻기 위한 알고리즘` 을 구현하지는 않는다. 예로, `document.createElement` 나 혹은 해당 컴포넌트의 `변경사항을 체크하는 알고리즘` , `리-렌더링` 여부에 대한 알고리즘을 구현하지 않는다.

이와 같은 선언형 특성은, 리액트를 사용할 때 `화면 설계` 라는 초점에 맞추어 개발할 수 있도록 해주므로, 다른 부분에 대한 고민을 최소화 해주어 `높은 생산성` 을 보장할 수 있도록 해준다.

#### 📍 Component Based Development

우리는 `Component` 단위로 개발을 해야 한다.

`컴포넌트` 는 독립적인 단위의 소프트웨어 모듈을 말한다. 즉, 소프트웨어를 독립적인 하나의 부품으로 만드는 방법이다. 리액트는 웹에서 쓰는 각 요소들을 컴포넌트로 만들 수 있게 해 `기존의 UI` 를 다른 화면에서 `다시 쓰거나` , 다른 프로젝트에서 다시 쓸 수 있도록 하는 장점 `높은 재사용성` 을 가진다.

```jsx
// HTML Element 와 Component

// HTML
<img src="이미지 주소" />
<button class="클래스명">버튼</button>

// Component
<MyComponentWrap name="Pham YoonTae" />
<MyComponentBox prop={false}>팜윤태</MyComponentBox>
```

HTML element와 Component를 비교해서 살펴보자.
먼저 컴포넌트는 `내가 지은 이름` 으로 태그를 만들 수 있다.

또한 `img` 태그에서 `src` 를 설정해준 것처럼 컴포넌트에서도 `name` 을 `Pham YoonTae` 라고 설정해주었다. img에서 src 속성은 주소를 바탕으로 이미지를 그리지만, `MyComponentWrap` 에서는 해당 태그에 어떤 로직을 작성했는지 모르지만 태그 안에서 `name` 안에 들어 있는 값을 사용할 수 있을것이다.

HTML에서는 `attr / attribute` 라고 하지만 컴포넌트에서는 `prop` 이라고 한다. 외부요소에서 `<MyComponentWrap>` 태그 안으로 어떠한 데이터를 넣어주고 싶을 때 `prop` 을 사용한다.

`<button class="클래스명">버튼<button>` 을 보게되면 "버튼" 이라는 문자열을 읽어들여 렌더링할 때 사용한다. 이는 컴포넌트에서또한 마찬가지다. 컴포넌트 태그 사이에 데이터를 담을 수 있는데 이는 `children` 이라는 `prop` 으로 받을 수 있으며 현재 `MyComponentBox` 가 가지고 있는 `prop`은 `props` 라는 객체에 들어있으며 

> { prop: false, children: "내용" } 

모양의 객체이다. 

사용자 입장에서 HTML과 컴포넌트는 크게 다르지 않다. 그러나 `<img> / <button>` 는 이미 어떻게 동작할지 구현되어 있지만 `Component` 들은 어떻게 동작할지 구현되지 않았다. 즉, 개발자 임의로 `props` 를 받아서 그 안에서 어떻게 표현되고 어떻게 동작할지 구현이 가능하다는 뜻이다.

#### 📍 Virtual Dom : 가상 돔

리액트는 `가상 돔` 을 사용하여 웹 애플리케이션의 성능을 극대화 시켰다. 이 가상돔은 어딘가에 데이터로만 존재하며 가상의 트리구조를 만들고 이를 실제로 브라우저에 그리는것이다. 가상돔을 이해하기 위해서 우선 `HTML / CSS` 가 `렌더링` 되는 과정을 이해해야한다.

#### ✅ HTML / CSS가 렌더링되는 과정

![스크린샷 2023-08-09 오후 11 43 02](https://github.com/chromeheartz/TIL/assets/95161113/665b84b2-846e-471d-a710-2242bdacffbd)

웹 브라우저가 `네트워크` 를 통해 HTML을 전달받으면 브라우저의 렌더링 엔진은 HTML을 `파싱` 하고 `돔 노드` 로 이루어진 트리를 만든다. 또한 `CSS파일 / HTML요소(element)` 의 인라인 스타일을 파싱하여 스타일 정보를 가진 `스타일 트리` 도 생성한다.

이렇게 `렌더 트리가 완성` 되면 브라우저는 `Attachment` 라는 과정을 통해 스타일 정보를 계산한다. 렌더 트리로 생성된 모든 노드들은 `attach` 라는 함수를 가지고 있는데, 이 `Attachment` 라는 과정에서 이 메소드들이 `호출` 되게 되며, 해당 메소드는 스타일 정보를 계산하고 `결과값을 객체 형태` 로 반환하게 된다.

이때 이 계산 과정은 모두 `동기적` 으로 동작하게 되며, 만약 렌더트리에 `새로운 노드` 가 추가된다면 해당 노드의 `attach` 메소드가 실행되어 계산 과정을 거치게 된다.

렌더 트리는 `Attachment` 과정을 거친 후 `레이아웃` 이라는 과정을 거치게 된다. 이 레이아웃 과정에서는 브라우저가 렌더 트리의 각 노드들에 좌표를 부여하고 정확히 `어디에 어떻게` 표시되는지를 결정한다. 

마지막으로 브라우저는 `페인팅` 과정을 거치게 되는데 이 과정에서 각 노드들에 `paint` 함수를 호출하여 렌더링된 요소들에 색상을 입히게 된다.

이런 과정을 거쳐 표시된 HTML을 자바스크립트를 사용하여 `DOM을 조작` 하게 되면 각 노드의 `좌표를 계산` 하기 위해 `레이아웃 과정` 이 다시 실행되고, 그 이후 `페인팅` 과정이 진행된다. 이렇게 DOM 조작으로 레이아웃 과정이 다시 진행되는 것을 ⭐️ `리플로우(Reflow)` 라고 하며, 페인팅 과정이 다시 진행되는 것을 ⭐️ `리페인트(Repaint)` 라고 한다. 이 `리플로우 / 리페인트` 는 DOM의 각 노드에 대한 연산 과정을 다시 수행함으로써 이 과정이 많이 수행될수록 웹 서비스의 성능이 저하되는 문제가 발생한다.

#### ❗️ 리액트

리액트는 이 `리플로우 / 리페인트` 가 자주 수행되는 문제를 해결하기 위해 `표시되는 DOM` 과 `동일한 DOM` 을 메모리상에 만들고 DOM 조작이 발생하면 메모리상에 생성한 `가상 돔에 모든 연산을 수행한 후` , `실제 DOM` 을 갱신하여 `리플로우 / 리페인트` 연산을 최소화 하였다.

돔을 직접 제어하려고 하면 `매번 바뀐 부분` 을 `정확하게 파악` 해서 바꿔주어야 한다. 그런데 직접 제어하지 않고 표현하기만 한다면 (이때는 A를, 다른때는 B를 그려라) 알아서 상태를 비교해서 자동으로 렌더링 해준다. 

![스크린샷 2023-08-10 오전 12 23 54](https://github.com/chromeheartz/TIL/assets/95161113/0b654839-3455-4977-a2ca-fba2a6d0afb6)

리액트는 항상 `두 개의 가상돔 객체` 를 가지고 있다.
- `렌더링 이전` 화면 구조를 나타내는 가상돔
- `렌더링 이후` 에 보이게될 화면 구조를 나타내는 가상돔

리액트는 `state(상태)` 가 변경될 때마다 `리-렌더링` 이 발생하는데, 이 시점마다 새로운 내용이 담긴 가상돔을 생성하게 된다. 실제 브라우저가 그려지기 이전에.

렌더링 이전에 화면의 내용을 담고 있는 `첫 번째 가상돔` 과 업데이트 이후에 발생할 `두 번째 가상돔` 을 비교해 `정확히 어떤 Element` 가 변했는지를 비교한다. 이를 React에서는 `Diffing` 이라고 표현한다.

이를 통해 `차이가 발생한 부분` 만을 (브라우저상의) 실제 DOM에 적용하게 되는것이고, 이 과정을 `Reconcliation(재조정)` 이라고 한다. 이 과정이 매우 효율적인 이유는 `Batch Update` 때문인데, 이는 변경된 모든 Element들을 `집단화` 시켜 이를 한번에 `실제 DOM` 에 적용하는 방식이다. ❗️ 부모가 바뀌면 자식까지 바뀔 가능성이 있어 `상태가 변한곳 + 상태가 변한곳의 자식` 까지 검사 후 바뀐게 있다면 다시 렌더 한다.

#### 📍 JSX

`JSX` 는 자바스크립트를 확장한 문법이다.

JSX는 템플릿 문자열이 아니라 `자바스크립트` 로 변환되는 코드이다. `javascript` 에 `XML` 을 추가해 확장한 문법이며, 공식적인 javascript 문법은 아니다. 리액트에서는 본질적으로 `렌더링 로직` 이 `UI 로직` (이벤트가 처리되는 방식, 시간에 따라 state가 변하는 방식, 화면에 표시하기 위해 데이터가 준비되는 방식 등)과 연결된다는 사실을 받아들인다. 

React는 `JSX 사용이 필수가 아니지만` , `UI 관련 작업` 을 할때 `시각적 / 가독성면` 에서 도움이 된다. 또한, 에러 및 경고를 메시지를 표시할 수 있게 해준다.

```jsx
// 예시 : 표현식 포함하기
const name = 'Pham Hanni';
const element = <h1>{name}</h1>
```

더 알고 싶으시다면 [`JSX`]

### 📌 CSR (Client Side Rendering) vs SSR (Server Side rendering)

`SPA` 인 리액트의 `렌더링 방식` 은 두가지로 나뉘게 된다.

#### 📍 CSR (Client Side Rendering)

`CSR` 의 구동방식은 초기 로드시 `빈 HTML` 과 모든 로직이 담겨있는 `JS` 를 다운로드 한다. 그 후 `JS` 를 이용하여 `DOM` 을 동적으로 생성하여 그려낸다.

![스크린샷 2023-08-10 오전 12 43 27](https://github.com/chromeheartz/TIL/assets/95161113/1d941a08-bfea-41e2-8782-917fda5bf878)

- 서버가 빈 html을 response했다. 화면에는 아무것도 보이지 않음
- html안에 들어있는 js 파일을 `서버로부터` 받아온다.
- 브라우저가 다운로드된 `js` 파일을 실행한다. (아직 로딩중)
- 리액트 실행 직후에 현재 경로에 해당하는 `페이지를 렌더링`. 이제 화면이 보이고 인터랙션이 가능하다.

`CSR` 은 보통 이동을 할 때 자바스크립트를 이용해 `동적으로 화면을 바꿔주므로` , html 문서가 가지고 있는 정보가 적어서 `검색엔진` 들이 웹사이트를 분석해서 내용들을 파악할 때 제대로 걸러지지 못해 `SEO(검색엔진 최적화)` 가 나쁘다. 

👍 :
	- JS를 사용해서 동적으로 그려내기 때문에 원하는 내용만 업데이트 할 수 있다. 
    - 빠른 페이지 이동이 가능하다. 
    - 서버에 데이터 요청하는 횟수가 적다
👎 :
	- SEO 친화적이지 않다
    - 처음에 모든 HTML / Static 파일을 로드해야한다.
    
#### 📍 SSR (Server Side Rendering)

`SSR` 의 구동방식은 완전히 만들어진 `HTML` 을 받아오고 렌더링하게 된다. `초기 로딩속도` 가 빠르기 때문에 컨텐츠를 빨리 볼 수 있다는 장점이 있지만 페이지 이동시, 느린 속도를 경험할 수 있다.

![스크린샷 2023-08-10 오전 12 56 14](https://github.com/chromeheartz/TIL/assets/95161113/2ae52b4e-7aa6-4c6b-8091-16af70458375)

- 서버가 문자열로 표현된 html을 내려준다.
- html을 `클라이언트가 받는 순간` 화면에 문서가 나타난다. 보이고나서 html안에 있는 `js` 를 받아온다. 화면이 보이기는 하지만 `사용할 수 없는 단계`
- 리액트 실행. 이때도 동작하지 않는다.
- 리액트가 실행된 후에 인터랙션이 가능하다.

`SSR` 은 매번 페이지를 요청할 때마다 새로고침이 되고, 서버에 `매번 요청` 하기 때문에 서버 부하도 클 수 있다.
하지만 `SEO` 에 친화적이기 때문에 리액트에 `서버사이드 렌더링` 을 얹던가 `Next.js` 를 사용하곤 한다.

[`Next.js`] : React로 만드는 서버사이드 렌더링 프레인 워크


👍 :
	- 초기 `로딩속도` 가 빠르다
    - `SEO` (검색 엔진 최적화 가능)
    
👎 :
	- 서버에 매번 요청을 해 속도가 느리고 서버가 부하가 걸릴 수 있다.
    - 페이지를 이동할 때마다 `화면 깜박임(화면이 로드될 때 백지로 변하고 출력되는 과정)` 이 있다.

[`MVC패턴`]: https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC
[`MVVM패턴`]: https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EB%B7%B0%EB%AA%A8%EB%8D%B8

[`선언형,명령형`]: https://velog.io/@nemo/%EC%84%A0%EC%96%B8%ED%98%95-%EB%AA%85%EB%A0%B9%ED%98%95

[`JSX`]: https://ko.legacy.reactjs.org/docs/introducing-jsx.html

[`Next.js`]: https://nextjs.org/