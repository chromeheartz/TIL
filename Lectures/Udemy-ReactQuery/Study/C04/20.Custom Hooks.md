## 더 큰 앱에서의 React Query: 설정, 집중화, Custom Hooks
### 20. Custom Hooks
---------------------------------------------

### 📌 Custom hook이란?

- `Custom hook` 은 컴포넌트 로직을 함수로 뽑아내어 재사용하기 위해 사용한다.
- hook은 항상 컴포넌트의 `최상위 코드에서만 호출` 되어야 한다. 이 규칙을 따라야 컴포넌트가 렌더링 될 때마다 항상 동일한 순서로 Hook이 호출되는 것을 보장 할 수 있다.
- Custom hook을 만들때 `이름은 use로 시작` 해야한다. 이를 따르지 않으면 특정한 함수가 그 안에서 Hook을 호출하는지를 알 수 없기 때문에 Hook 규칙의 위반 여부를 자동으로 체크할 수 없다.

#### 왜 Custom Hooks로 만들고 싶어할까?

React Query에서 제공하는 대표적인 Hook은 2가지가 있다. `useQuery / useMutation` 이 두가지는 Hook이기 때문에 반드시 `Functional Component` 안에서 사용해야 한다는 제약이 있다.

```jsx
const Component = () => {
  const { data } = usequery(['query-key'], queryFunc)
  
  // ...
}
```

이런식으로 사용했을 때 어떤 문제점들이 있을까?

- 컴포넌트에 네트워크 처리 코드가 `종속` 되는 느낌
📍 원래 컴포넌트는 `비지니스 로직` 을 가지고 있는 경우가 많고, 네트워크 요청을 촉발시키는 것이야 이상할 것은 없다. 하지만 네트워크 로직 코드를 `Server State` 를 가져오는 것이기도 하고, 재사용성을 생각해봤을 때 따로 분리하는 것이 좋다는 생각이 든다. 

- 코드 수정에 어려움이 있다.
📍 만약에 다른 컴포넌트에서도 `같은 API` 한테 데이터를 받아와야해서 `useQuery` 문을 작성했다고 가정해보자. 어느날 URI가 변경되어 `/member` 를 `/member/info` 이런식으로 변경 해야 한다면 이 URI를 사용하는 곳을 일일이 찾아서 수정해줘야 할 것이다. 
혹은 Query Key를 잘못 써서 같은 URI에 대한 같은 메서드임에도 불구하고 `캐싱이 다르게 된다거나` 하는 문제가 있으면 문제 해결에도 많은 시간이 걸릴것이다.

⭐️ 결국 **이런 코드들을 `모듈화` 해서 재사용을 용이하게 하고 유사시 수정도 쉽게 할 수 있도록 분리** 하면 이 문제들을 해결할 수 있다. `useQuery / useMutation` 은 Hook이라서 모듈화 하려면 새로운 `Custom Hook` 으로 감싸서 모듈화해야 하기 때문에 Custom Hook으로 만들어서 사용한다고 말하는 것이다.

