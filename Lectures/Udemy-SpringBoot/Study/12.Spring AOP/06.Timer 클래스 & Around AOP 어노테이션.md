## Spring AOP

### 06. Timer 클래스 / Around AOP 어노테이션

---

### 📌 @Around

`@Around` 는 메소드 `실행 전 과 후` 에 무언가를 한다.
즉, 메소드 실행 주변에 무언가를 하는것이다.
Aspects에 새로운 클래스를 하나 생성해서 확인해보자.`PerformanceTrackingAspect` 라는 이름으로 지어서 메소드가 실행된 시간을 알아보자.

그럼 먼저 타이머를 시작하고 메소드를 실행시키고 타이머를 멈추게 함으로써 메소드를 실행하는데 얼마나 걸렸는지 알 수 있다.

그래서 `@Around` 어드바이스를 추가해준다.
포인트컷으로 `인터셉트할 대상` 을 명시해줄것인데, 이전에 썼던 값을 그대로 써보자.
이후에 클래스를 `@Aspect` 로 만들어주고, `@Configurration` 을 추가해준다.

메소드 안에는 타이머를 구현하기 위해 `System.currentTimeMillis` 를 사용한다.
시작시간과 끝시간을 가져오고 끝시간에서 시작시간을 빼면 얼마나 걸린지 알 수 있다.

```java
long startTimeMillis = System.currentTimeMillis();
long endTimeMillis = System.currentTimeMillis();
long executionDuration = endTimeMillis - startTimeMillis;
```

`logger.info("Around Aspect - {} Method executed in {} ms", ,executionDuration);`

여기서 생각해보아야할것이 2번째 인자에서 기존에는 `joinPoint` 를 사용했었다.
그런데 조인포인트는 메소드를 실행시켜주지 않아서 조인포인트 대신 `ProceedingJoinPoint` 를 써야 한다.

`proceed` 란 메소드를 제공해 `AspectJ` 애스팩트중 Around애스팩트를 지원한다. 결국 `ProceedingJoinPoint` 건 결국 메소드를 실행시켜주는 것이다.
`proceed` 를 호출해 대상 메소드를 실행시킬 수 있다.

```java
@Aspect
@Configuration
public class PerformanceTrackingAspect {
	private Logger logger = LoggerFactory.getLogger(getClass());

	@Around("execution(* com.in28minutes.learn_springaop_13.*.*.*(..))")
	public Object findExecutionTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
		long startTimeMillis = System.currentTimeMillis();

		Object returnValue = proceedingJoinPoint.proceed();

		long endTimeMillis = System.currentTimeMillis();

		long executionDuration = endTimeMillis - startTimeMillis;

		logger.info("Around Aspect - {} Method executed in {} ms", proceedingJoinPoint ,executionDuration);
		return returnValue;
	}
}


// 결과
2025-08-24T15:48:43.204+09:00  INFO 59287 --- [learn-springaop-13] [           main] erformanceTrackingAspect$$SpringCGLIB$$0 : Around Aspect - execution(int[] com.in28minutes.learn_springaop_13.data.DateService1.retrieveData()) Method executed in 0 ms
2025-08-24T15:48:43.205+09:00  INFO 59287 --- [learn-springaop-13] [           main] erformanceTrackingAspect$$SpringCGLIB$$0 : Around Aspect - execution(int com.in28minutes.learn_springaop_13.business.BusinessService1.calculateMax()) Method executed in 1 ms
```

이렇게 시간을 볼 수 있다. `BusinessService1` 로 가서 시간이 걸리게 할 수도 있다.
`Thread.sleep` 을 호출해주고 `try-catch` 문을 삽입해주면 된다.

```java
	public int calculateMax() {
		int[] data = dataService1.retrieveData();
//		throw new RuntimeException("Something Went Wrong!");

		try {
			Thread.sleep(30);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		return Arrays.stream(data).max().orElse(0);
	}

// 결과
2025-08-24T15:51:40.112+09:00  INFO 61733 --- [learn-springaop-13] [           main] erformanceTrackingAspect$$SpringCGLIB$$0 : Around Aspect - execution(int com.in28minutes.learn_springaop_13.business.BusinessService1.calculateMax()) Method executed in 37 ms
```

아까보단 실행시간이 조금 더 크게 나왔다.
`dataService` 쪽에도 추가시켜줄 수 있다.
이제 구현한 로직이 공통적으로 적용되고 있다. `BusinessService2` 를 만들어서 `max` 가 아닌 `min` 으로 최소값을 구해보자. 여기서 사용하는 데이터는 `DataService2` 로 만들어서 다른 배열을 만들어서 호출해보자.

물론 각각 필요한 `생성자 주입` 들은 다 해주어야 한다.
이렇게 하면 로그에 다 나오는 것을 볼 수 있다.

> ✅ 지금까지 했던 어노테이션들은 해당 패키지에 속한 클래스라면 다 적용할 수 있다.
> 한번 쓴 코드를 특정 패키지 안에 있는 여러 개 클래스에서 적용할 수 있는것인데, `AOP` 라서 가능한것이다. 어드바이스는 하나 만들어서 다양한 여러 레이어에 다 적용시킬 수 있다.
