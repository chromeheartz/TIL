## Spring AOP

### 02. Spring AOP / Spring Component

---

### 📌 Spring AOP 프로젝트 설정

`start.spring.io` 에서 필요한 설정을 해주고 시작하면 된다.
`add dependencies` 로 기존에 의존성을 추가했던 것과 다르게 `AOP` 는 직접 추가해주어야 한다.

`import` 해서 가져와서 시작해보면 잘 시작이 된다.
모든 의존성은 `build.gradle` 이라는 파일에 명시되어있는데, 여기에 프레임워크 관련 의존성을 명시하면 된다.

그룹 아이디는 `build.gradle` 에 있지만 아티팩트 아이디로 지정했던 것은 `settings.gradle` 에서 확인할 수 있다.

### 📌 Spring AOP에 필요한 Spring Component 만들기

일단 먼저 비즈니스 레이어를 만들것인데, 패키지를 `business` 로 지정해주고, `BusinessService1` 이라는 새로운 클래스를 만들자. 이 비즈니스 서비스는 `비즈니스 로직` 을 실행할것인데, 실행하기 위해서는 `데이터` 가 필요하다.

그러니 `데이터 서비스` 또한 추가되어야 한다. 데이터 서비스는 `data` 패키지에 만들어서 나누어놓자.
이 데이터 서비스는 보통 `MySQL / MongoDB` 같은 데이터베이스와 통신한다.

일단 하드코딩된 데이터를 반환하는 메소드를 만들어 놓자.

```java
public class DateService1 {
	public int[] retrieveData() {
		return new int[] {11, 20, 30, 44};
	}
}
```

간단하게 만들어놓고, 비즈니스 서비스에서 활용해보자.

```java
public class BusinessService1 {

	private DateService1 dataService1;

	public int calculateMax() {
		int[] data = dataService1.retrieveData();
		return Arrays.stream(data).max().orElse(0);
	}
}
```

배열에서 최대값을 찾기 위해 세팅해주고, 만약 없으면 0 을 반환하도록 설정
이제 어딘가에서 이 비즈니스 서비스를 실행해주어야 한다. 이 빈이 어딘가에서 쓰이도록
방법 하나는 `Command Line Runner` 라는 것을 구현하는 것이다.
`implements CommandLineRunner` 라는 구문을 `@SpringBootApplication` 어노테이션이 붙어있는 클래스에 사용하면 되는데, 해당 정보를 보게되면, `SpringApplication` 안에 있을 때 빈이 실행되야 함을 명시한다고 한다. `CommandLineRunner` 빈은 여러 개 써도 되고 빈의 순서는 `@Order` 어노테이션으로 표시하면 된다.

> ✅ 여기에서 알아두어야 할 것은 여기에 정의하는 로직은 `Spring Boot` 앱이 실행되는 순간 실행된다는 것이다.

구현되지 않은 메소드 컴파일 에러가 나오기 때문에 해당 부분을 `cmd + 1` 로 추가해주면,
추가된 메소드는 `run` 여기에 `해야 할 작업` 을 넣으면 된다.

비즈니스 서비스를 가져와서 `calculateMax()` 를 호출하고 해당 정보를 로그로 출력하기 위해 `Logger` 를 `pricate` 로 생성해준다.
`LoggerFactory.getLogger(getClass())` 를 할당해주고 임포트를 할것인데, `org.slf4j.Logger` 를 선택했다.

`logger` 를 사용하기 위해 `info("Value returned is {}", xx)` 여기서 xx에 해당하는 값에 아까 가져오려고 했던 값을 넣어주면 로그를 쉽게 알아볼 수 있다.

```java
@SpringBootApplication
public class LearnSpringaop13Application implements CommandLineRunner {

	private Logger logger = LoggerFactory.getLogger(getClass());

	private BusinessService1 businessService1;

	public static void main(String[] args) {
		SpringApplication.run(LearnSpringaop13Application.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		logger.info("Value returned is {}", businessService1.calculateMax());


	}

}

// 오류 발생
java.lang.NullPointerException: Cannot invoke "com.in28minutes.learn_springaop_13.business.BusinessService1.calculateMax()" because "this.businessService1" is null
```

여기까지 했을때 실행해보면 `오류` 가 나오게 된다. `NullPointerException` 이다 함수 호출이 불가하다. `businessErvice1` 이 `null` 이라서 나온 에러이다.

> ✅ `@Autowired` 처리를 안해줘서 생긴것
> Sevice들에 `@Service` 어노테이션을 넣어주고 어디서든 멤버변수로 가져와서 쓰고 있는 곳에는 `@Autowired` 로 연결해주면 사용가능하다.

하지만 이 방식 대신에 `생성자 주입` 으로 해보자.

```java
	public LearnSpringaop13Application(BusinessService1 businessService1) {
		this.businessService1 = businessService1;
	}

// 오류
Consider defining a bean of type 'com.in28minutes.learn_springaop_13.business.BusinessService1' in your configuration.
```

이렇게 넣어주고 시작을 해도 오류가 발생한다.
BusinessService1을 찾지 못해서 `BusinessService1` 을 빈으로 정의하는것을 고려해보라고 한다.

> 비즈니스 서비스에 `@Component` 어노테이션을 붙이면 해결된다.
> 해당 어노테이션은 `범용 스테레오타입 어노테이션` 인데, 비즈니스 레이어는 서비스 레이어이기 때문에 `@Service` 가 권장된다. 따라서 `@Service` 로 진행.

```java
	public BusinessService1(DateService1 dataService1) {
		this.dataService1 = dataService1;
	}
```

비즈니스 서비스에서도 생성자주입으로 만들어준다.

> 여기서 `DataService` 에도 `@Service` 를 붙이면 될까 생각하는데, 데이터 레이어이기때문에 `@Repository` 를 붙여주는것을 선호한다고 한다.

이렇게하고 실행해보면
로그에 `2025-08-23T13:31:28.678+09:00  INFO 10581 --- [learn-springaop-13] [           main] c.i.l.LearnSpringaop13Application        : Value returned is 44
` 로 잘 나오는 것을 볼 수 있다.
