## Spring Security

### 16. JWT로 인증설정하기 - 2

---

### 📌 JWT로 인증설정하기

`JwtDecoder` 가 필요하다. 이를 만들려면 먼저 `RSA 키 쌍` 을 만들어야 한다.
`공개 키 / 비밀 키` 를 생성해야 `RSA 키 객체` 를 만들 수 있다.
그 이후 `JWKSource` 라는 것을 만들 수 있고, 이 다음에야 디코딩에 사용할 수 있다.

#### 키 쌍

`openssl` 이라는 툴이 있고, 이 툴로 `RSA 공개 키 / 비밀 키` 를 만들 수 있는데, 코드를 통해 이 키 쌍을 만들려고 한다. `KeyPairGenerator` 라는 `Java Class` 를 이용할것이다.
이 제너레이터의 타입을 열면 이게 실제로 `java.security` 의 일부라는 것을 알 수 있다.
그리고 실제로 예를 들어 `generatorKeyPair()` 같은 메소드를 갖고 있고, 이것으로 키 쌍을 만들 수 있다.
`RSA 알고리즘 키 쌍` 을 만들것이다.

`@Bean` 을 생성하고, `KeyPair` 를 가져와서 쓸것이다.
이 안에 `KeyPairGenerator` 클래스를 사용하고 `RSA 알고리즘` 을 위해 인스턴스를 받을것이다. `.getInstance("RSA");` 라고 해주고, 그것을 변수로 선언해준다.

```java
// throw
@Bean
public KeyPair keyPair() throws NoSuchAlgorithmException {
    var keyPairGenerator = KeyPairGenerator.getInstance("RSA");
    keyPairGenerator.initialize(2048);
    return keyPairGenerator.generateKeyPair();
}

// try-catch
@Bean
public KeyPair keyPair() {
    try {
        var keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    } catch (Exception ex) {
        throw new RuntimeException(ex);
    }
}
```

강의와는 다르게 `throws` 를 사용해서 오류를 막아주었다.
`getInstance` 가 미처리 오류를 내고 있다. 즉, 예외를 내고 있는데,
`NoSuchAlgorithmException` 이라고 나온다. `try-catch` 문으로도 사용 가능하다.

체크된 예외를 미체크 또는 런타임 예외로 변환해주고 있는 것이다.
이렇게 키 쌍을 만들고 실행.

#### RSA 객체

키 쌍을 이용해서 `RSA 객체` 를 만들어야 한다.
`RSA 인코딩 / 디코딩` 을 위해 `nimbus` 라는 라이브러리를 사용할 것이다.
이미 클래스 패스에 있고, `OAuth` 리소스 서버 의존성에 포함되어 있다.

`nimbus RSAKey` 객체를 만들면된다.
여기에는 모든 설정이 들어가는데, 공개 키를 받는 `Builder()` 가 있고, `KeyPair keyPair` 를 인수로서 넣어줄것이다.

그리고 키 쌍에는 `공개 키 / 비밀 키` 가 있고, 공개 키를 사용할것이기 때문에 `.getPublic()` 이라고 해준다. `RSAKey` 는 `com.nimbusds.jose.jwk.RSAKey` 에서 임포트 해온다.

이 후 `비밀 키` 도 설정해야 하기 때문에, `.privateKey(keyPair.getPrivate())` 라고 하고 `ID` 를 설정한다.
`keyID` 라고 하고, `UUID` 로 생성해주고, 타입 캐스팅을 하기 위해 `(RSAPublicKey)` 를 추가해주고 임포트 해준다.

```java
	@Bean
	public RSAKey rsaKey(KeyPair keyPair) {
		return new RSAKey
				.Builder((RSAPublicKey)keyPair.getPublic())
				.privateKey(keyPair.getPrivate())
				.keyID(UUID.randomUUID().toString())
				.build();
	}
```

이렇게 `RSA 객체` 를 만들 수 있다.

#### JWKSource

일반적으로 다수의 키가 있는 `JSON 세트` 를 만들 수 있다.
`RSA 키 하나만 있는 JWKSet` 을 만들것인데, 이것을 이용해서 `JWKSource` 를 만들것이다.
사실 이 모든것들은 일회성 설정이다. (매일같이 변경하는건 아니라는 뜻)

`JWKSource` 도 `nimbusas.jose.jwk.source` 에서 가져오고, RSAKey가 필요한데, 파라미터로 넣어서 가져온다.

```java
	@Bean
	public JWKSource jwkSource(RSAKey rsaKey) {
		var jwkSet = new JWKSet(rsaKey);
	}
```

이렇게 만들어 놓고 `JWKSet` 을 이용해서 `JWKSource` 를 만들어야 한다.
일단 `JWKSource` 를 확인해보면 오버라이드해야할 `get()` 메소드가 있다. 그럼 구현물을 만들어서 `get()` 메소드에 대한 구현물을 제공하면 된다.

`new JWKSource` 를 해놓고 `cmd + 1` 으로 `Add unimplemented methods` 를 선택하면 `override` 할 메소드를 쉽게 가지고 온다.

`return` 할 곳에 `JwkSelector.select()` 라고 하고 `jwkSet` 을 넣어주면 된다.
여기서 항상 `jwkSet` 을 선택하고 있는데, 키를 사용하려 할 때는 항상 이 키 세트를 사용하게 된다.

키를 사용하려 할 때 `jwkSet` 을 사용하게 되는것.

```java
@Bean
public JWKSource<SecurityContext> jwkSource(RSAKey rsaKey) {
	var jwkSet = new JWKSet(rsaKey);

	return (jwkSelector, context) -> jwkSelector.select(jwkSet);
}
```

`람다 함수` 로 간단하게 정리했다.
일단 현재까지의 코드를 보면 `KeyPair` 를 만들고 그 이후에 `RSAKey` 를 만들었다.
이 `RSAKey` 를 이용해서 `JWKSource` 를 만들었고, 디코딩을 위해 `RSA 공개 키` 를 만들어야 한다.

#### JwtDecoder

`decoder` 를 만들다가 말았는데, 이제 어떻게 만들까?
`NimbusJwtDecoder` 라는 타입을 열게 되면, `Nimbus` 가 `디코더 / 인코더` 를 모두 제공하는 것을 볼 수 있다. 여기서 `withPublicKey()` 메소드를 사용할것인데, 이 메소드는 `RSAPublicKey()` 를 받고, 이것의 인스턴스를 생성해서 디코딩에 사용할것이다.

```java
	@Bean
	public JwtDecoder jwtDecoder (RSAKey rsaKey) throws JOSEException{
		return NimbusJwtDecoder
				.withPublicKey(rsaKey.toRSAPublicKey())
				.build();
	}
```

디코더의 메소드를 사용하는데 여기에 `rsaKey` 를 연결해주어야 한다. 이후에 `build` 로 return해주면 끝.

여기서 `JOSEExcpetion` 을 미처리 예외타입을 안넣어주면 컴파일 오류가 나기 때문에, 구문을 작성해주어야 한다.

이렇게 하면 앱이 잘 시작되는데 이렇게 하면 키 쌍을 만들고, `JWT 토큰` 을 위해 `디코더` 를 설정하게 되는것이다.
