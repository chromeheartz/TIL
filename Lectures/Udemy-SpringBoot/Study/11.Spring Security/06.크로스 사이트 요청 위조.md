## Spring Security

### 06. 크로스 사이트 요청 위조

---

### 📌 크로스 사이트 요청 위조

`CSRF` 사이트 간 요청 위조에 대해 알아보자.
이는 무엇일까?
사용자가 은행 웹 사이트에 로그인했다고 가정해보자. 은행 웹사이트는 대개 웹 애플리케이션이므로 `쿠키` 가 생성돼서 웹 브라우저에 저장된다.
그런데 사용자가 로그아웃 하지 않은 상태에서 `악성 웹사이트` 로 이동하면 사용자가 알지 못하는 상태에서 쿠키를 이용해 은행 웹사이트에 요청을 실행한다.

그럼 브라우저의 쿠키는 어떻게 될까?
다른 웹사이트에서는 이 쿠키에 엑세스하고 이용해서 사용자 대신 요청을 실행할 수 있다.
이러한 문제를 `사이트 간 요청 위조` 라고 한다.

#### 사이트 간 요청 위조로부터 보호하는 방법은 무엇일까?

한 가지 옵션은 `동기화 토큰 패턴` 을 이용하는 것이다.
`요청마다` 토큰을 생성하는 것이다. `세션 ID`, 즉 세션 쿠키가 사용자 세션마다 한 번씩 생성되지만 더 좋은 방법은 `요청마다 토큰을 생성` 하는 것이다.

그래서 사용자가 탐색하는 페이지 각각 사용자가 수행하는 작업 각각에 새 토큰을 생성하는 것이다.
그리고 `POST, PUT` 과 같은 업데이트 요청이 있을 때, 예를 들어 송금이 발생하면 토큰으로 인증한다.

애플리케이션에서 업데이트 작업을 할 때마다 이전 요청에서 생성된 토큰을 사용해야 한다.
`Spring Security` 는 이 기능을 기본적으로 사용 설정한다는 장점이 있다.
이 기능이 어떻게 작동하는지 보자.

일단 패키지를 `resources` 로 새로 만들어서 옮기자.
`package` 뒤에 `.resources` 를 하고 `cmd + 1` 을 하면 바로 변경이 가능하다.

#### 해야 할 것

이제 수행할 작업은 `Todo List` 를 만들어 반환하는 것이다.
간단하게 `/todos` 라고 지정.

```java
@RestController
public class HelloWorldResource {
	@GetMapping("/todos")
	public List<Todo>retrieveAllTodos() {
		return List.of(new Todo("toyatae","Learn AWS"), new Todo("toyammi", "Learn JP"));
	}
}

record Todo (String username, String description) {

}
```

간단하게 시스템에 있는 모든 할 일 리스트를 만들고, `List.of()` 를 사용해 할 일 리스트를 반환한다. 그리고 레코드 기능을 생성. `record` 를 만들어 놓고 `오버라이딩` 을 하지 않는다는 의미로 본문은 비워놓는다.

이미 기본 권한 부여 헤더를 추가해두었는데, `/todos` 에 인증을 넣고 요청을 넣어보면 제대로 작동하는 것을 볼 수 있다.
이제 다른 메소드를 만들것이다.

`retrieveTodosForSpecificUser` 로 새로운 함수를 하나 만들어서 여기에는 특정 사용자에 대해 사용할것인데, `/users/{username}/todos` 라고 지정하면 된다.
`@PathVariable` 을 사용하는데 타입은 `String` 이름은 `username` 이 된다.
매개변수에서 이렇게 받아오면 `TODOS_LIST(상수로 만들어놓은것)` 리스트에서 `get(0)` 하면 가져올 수 있다.

```java
	@GetMapping("/users/{username}/todos")
	public Todo retrieveTodosForSpecificUser(@PathVariable("username") String username) {
		return TODOS_LIST.get(0);
	}

```

강의에서는 `@PathVariable` 만썼었는데 현재 버전에서는 Spring이 `@PathVariable` 의 변수명을 추론할 수 없기 때문에 명시적으로 작성해주었다.

이제 `POST` 요청을 추가해보자.
새 리소스를 생성할 때 사용하는것인데 `PostMapping` 을 추가하면 어떻게 될까?

일단 그 전에 로거를 생성해서 정보를 로깅해보자.
`private Logger logger = LoggerFactory.getLogger(getClass())`

```java
@PostMapping("/users/{username}/todos")
	public void createTodoForSpecificUser(@PathVariable("username") String username, @RequestBody Todo todo) {
		logger.info("Create {} for {}", todo, username);
	}
```

이렇게 만들어놓고 `POST` 요청을 `request` 형식에 맞춰서 보냈을때 `401` 이 반환된다.
실패 이유가 무엇이고, 어떻게 수정해야할까?

> 이 단계에서는 `CSRF`, 사이트간 요청 위조에 대해 알아보았다.
> 웹사이트에 로그인하면 웹 브라우저에 쿠키가 저장된다.
> 로그아웃 하지 않은 상태에서 악성 웹사이트로 이동하면 악성 웹사이트는 브라우저의 쿠키를 이용해 은행 웹사이트같은곳에 요청을 실행할 수 있는데 이것이 `사이트 간 요청 위조` 이다.

> 사이트간 요청 위조로부터 보호하는 솔루션중 하나는 `동기화 토큰 패턴` 이다.
> 요청 각각에 대해 토큰을 생성하고 업데이트할 때마다 `CSRF` 토큰을 사용하는 것이다.
