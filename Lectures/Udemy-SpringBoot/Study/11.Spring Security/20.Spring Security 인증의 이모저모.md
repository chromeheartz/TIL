## Spring Security

### 20. Spring Security 인증의 이모저모

---

### 📌 Spring Security 인증의 이모저모

![](https://velog.velcdn.com/images/bibiboy/post/3dd52b0f-c7b6-4484-b177-00c35a308fec/image.png)

`Spring Security` 인증에는 두 가지 접근법이 있다.
`전역 보안 / 메소드 보안` 이다.

일단 `JWT 인증` 을 비활성화하고 기본 인증할 때 사용한 `@Configuration` 을 활성화할것이다.
`JwtSecurityConfiguration / JwtAuthenticationResource` 이 두 곳에서 주석을 걸어주자.

`BasicAuthSecurityConfiguration` 으로 가서 다시 어노테이션 주석을 풀어주자.
`JWT 보안` 을 사용할 때는 코드를 변경할 때마다 `JWT` 를 다시 생성해야 한다.
기본인증을 시작하면 `todos` 에 `GET` 요청을 제출할 수 있다.

#### 전역 보안

전역 보안은 `authorizeHttpRequests` 에서 설정할 수 있다. 앞에서 `필터 체인` 을 만들었는데, 그럼 `BasicAuthSecurityConfiguration` 에서 인증에 관련된 더 많은 내용을 설정할 수 있다.

`requestMatchers("/users").hasRole("USER")`
예를 들어 `특정한 URL` 이 `USER` 라는 역할을 가져야 한다고 할 수 있다.
또 만일 `admin` 으로 시작되는 무언가가 있다면 즉, `/admin/**` 가 있다면 `ADMIN` 이라는 역할을 가져야 한다고도 할 수 있다.
이렇게 직접 여기서 `URL 기준 인증` 을 설정할 수 있다.

또한 다양한 매처들도 많은데 `hasRole / hasAuthority, hasAnyAuthority, isAuthenticated` 등이 있다.

```java
http.authorizeHttpRequests(auth -> {
			auth
				.requestMatchers("/users").hasRole("USER")
				.requestMatchers("/admin/**").hasRole("ADMIN")
				.anyRequest().authenticated();
		});
```

📍 이런식으로 매처를 사용해 `인증 규칙` 을 설정할 수 있다.

#### 메소드 보안

메소드 보안을 사용하려면 `@EnableMethodSecurity` 로 활성화 시켜주어야 한다.
이렇게 메소드보안을 활성화했다면, `@Pre / @Post` 같은 어노테이션을 사용할 수 있다.

`@PreAuthorize("hasRole('USER') and #username == authentication.name")`
이 메소드에 액세스하려면 사용자가 `USER` 역할을 갖고 있어야 한다고 할수도 있다.

```java
	@GetMapping("/users/{username}/todos")
	@PreAuthorize("hasRole('USER') and #username == authentication.name")
	public Todo retrieveTodosForSpecificUser(@PathVariable("username") String username) {
		return TODOS_LIST.get(0);
	}
```

`username` 이 인증에 있는 `name` 과 일치해야한다는 조건을 추가할 수 있다.
그러면 username으로 들어가는 패스변수가 인증에 있는 이름과 매칭되어야 한다고 할 수 있다.
기존에 `localhost:8080/users/in28minutes/todos` 로 했을때는 제대로 `200` 이 떨어지는데 `dummy` 같이 `username` 을 바꾸게 되면 `403` 으로 에러가 나오는 것을 볼 수 있다.

`@PostAuthorize("returnObject.username == 'in28minutes'")`
또한 `PostAuthorize` 같은 것도 할 수 있다. 리턴객체에서 username이 `in28minutes` 인지도 확인 할 수 있다.

> ✅ 메소드 수준 보안에서는 `PreAuthorize / PostAuthorize` 를 사용하는 것이 좋다.

`JSR-250` 어노테이션으로도 메소드 수준 보안을 구현할 수 있는데, 이 어노테이션을 사용하려면 `jsr250Enabled=true` 로 설정해야 한다.

`@EnableMethodSecurity(jsr250Enabled=true)`

이렇게 설정하고 `TodoReSource` 에서 `@RolesAllowed()` 를 추가한다.

```java
	@GetMapping("/users/{username}/todos")
	@PreAuthorize("hasRole('USER') and #username == authentication.name")
	@PostAuthorize("returnObject.username == 'in28minutes'")
	@RolesAllowed({"ADMIN", "USER"})
	public Todo retrieveTodosForSpecificUser(@PathVariable("username") String username) {
		return TODOS_LIST.get(0);
	}
```

여기서 `@RolesAllowed` 어노테이션은 `jakarta.annotaion.security.RolesAllowed` 인데, 이 안을 들어가보면 `@DenyAll / @PermitAll` 같은 다른 어노테이션들도 있다.

요청을 제출하면 성공하는데, `"ADMIN1", "USER1"` 으로 바꾸고 제출하면 `403` 이 되돌아온다.

📍 `역할이 없기 때문`

이렇게 `jsr250Enabled=true` 라는 속성으로 메소드 수준 보안을 활성화해서 `JSR-250 어노테이션` 을 사용할 수 있다.
`securedEnabled` 도 추가해서 활성화시켜보고, 리소스에서 존재하지 않는 역할 (ADMIN1, USER1) 로 바꾸고 요청을 제출해보면 `403` 을 받고 있다.

✅ `@Secured` 는 사실 권한과 비교해서 확인을 한다. 따라서 `ROLE_ADMIN`, `ROLE_USER` 라고 하면 요청이 성공되는 것을 볼 수 있다.

> ✅ `@Pre / @Post` 를 사용하는 것을 권한다.
> 그렇게 하면 유연성이 높아지고, 최근에 많이 쓰는 방식이다.
> 표준을 준수해야 한다면 `JSR-250 어노테이션` 을 사용하도록 하자.
