## Express.js

### 02. Express 초기 설정 & 미들웨어 추가

---

### 📌 Express 초기 설정

`npm install --save express `
로 express를 설치해준다. 여기서 `--save` 를 사용하는 이유는 `프로덕션 의존성` 이기 때문이다.
개발중에만 사용하는 툴 뿐만 아니라 애플리케이션의 한 부분으로 통합될것이며 이후 배포한 뒤에 실행하게 될 모든 서버와 컴퓨터에 설치되어야 한다.

`app.js` 에서 `express` 를 불러온다.
상수에다가 저장하기 위해 `app` 이라는 이름으로 저장해놓고 `express` 를 함수로서 실행한 상태이므로 결국 express 패키지는 마지막에 함수를 내보내는 것으로 보인다.
`express` 를 cmd + click으로 누르면 `index.d.ts` 로 소스코드로 이동하게 되는데 마지막에 있는 `export = e;` 에서 내보내는 것을 보고있다. 이게 함수에 해당한다.

그러니까 함수로 실행하게 되면 새로운 객체를 초기 설정하게 되는데 프레임워크가 배후에서 많은 내용을 저장 관리한다. 따라서 이 앱에서 많은 로직이 `app` 상수에 들어가 있고, 유효한 요청 핸들러이다.
따라서 이를 server.listen에 전달하여 서버를 생성할 수 있다.

### 📌 미들웨어 추가

![](https://velog.velcdn.com/images/chromeheartz/post/80f5c698-5fb4-4ddb-a478-5610f130eefd/image.png)

`Express` 는 미들웨어와 깊게 연관되어 있고 이미지를 보면 최종적으로 미들웨어의 뜻은 들어오는 요청을 `express.js` 에 의한 다양한 함수를 통해 자동으로 이동하는 것이다.

> ✅ 즉, `단일 요청 핸들러` 를 보유하는 대신 응답을 전송하기 까지 `요청이 통과하게 될 다양한 함수` 들을 연결할 가능성을 확보하게 되는것이다.

이를 통해 모든 걸 하나의 함수를 사용하여 처리하기 보다는 코드를 `다수의 블록 / 조각` 들로 분할할 수 있는 것이 `Express` 의 특징이다.

미들웨어 기능들을 제공하는 `thirdparty package` 를 express에 장착하여 특정 기능을 추가하면 된다.
app 객체를 생성한 시점 이후 서버를 생성하기 위해 전달한 지점 앞부분에 사용할 수 있다

#### use

express 프레임워크가 정의하는 `use` 메소드를 호출할 수 있다.
이는 새로운 미들웨어 함수를 추가할 수 있는데 `요청 핸들러의 배열` 을 받아들일 수도 있고, 함수를 간단하게 전달할 수 있다.
`app.use` 로 전달하는 함수는 모든 들어오는 요청마다 실행될것이며 `3가지 인수` 를 받는데, `request, response, next` 이다.

`next` 는 사실 함수로 `epxress` 를 통해 전달되는 함수이며, use에 함수를 인수로서 전달하는것이 혼란스러울 수 있는데, 이렇게 전달하는 함수는 `next` 인수에 있는 `또 다른 함수` 를 수신하며 다음 미들웨어로 요청이 이동할 수 있도록 실행되어야 한다.

```js
// app.js
const http = require("http");

const express = require("express");

const app = express();

app.use((req, res, next) => {
  console.log("middle ware called");
  next();
});
app.use((req, res, next) => {
  console.log("In another middleware!");
  res.send("<h1>Hello from Express!</h1>");
});

const server = http.createServer(app);

server.listen(3000);
```

이렇게 미들웨어를 작성하게 되면 "middle ware called"가 출력이 되고 그 이후에 "In another middleware!"가 출력이 되고 응답이 실행이 된다.

즉, 모든 미든웨어 함수를 거쳐 아래로 내려가는 셈인데 `next` 를 호출하지 않으면 그냥 멈추고 따라서 next를 호출하지 않는 경우 `응답을 다시 전송` 해야 한다.
왜냐하면 그렇지 않으면 요청이 계속 이동할 수 없고, 해당 부분에 머무르기 때문이다.
아무것도 보내지 않게 되는 셈이다.
