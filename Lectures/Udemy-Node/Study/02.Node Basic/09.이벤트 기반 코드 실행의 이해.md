## Node Basic

### 09. 이벤트 기반 코드 실행의 이해

---

### 📌 이벤트 기반 코드 실행

헷갈려하는 중요한 부분 중 하나는 `코드를 작성하는 순서대로 실행되는 것이 아니라는 것` 이다.
예를 들어 `fs.writeFileSync()` 같은 경우는 아래에 있는 코드 후에 실행된다. 심지어 응답을 발송하고 난 `후` 에 실행될것이다. 여기에는 중요한 의미가 있다.

> ✅ 먼저 `응답 발송` 은 이벤트 리스너 실행이 끝났다는 의미가 아니다. 응답이 발송된 후에도 이벤트 리스너는 계속 실행된다. 동시에 이벤트 리스너(req.on)에 응답에 영향을 줄 수 있는 어떠한 처리를 하는 것은 잘못된 설정이다. 그러면 응답 코드를 이벤트 리스너에 넣어야 한다.

`Node.js` 는 함수를 함수 안에 넣으면 안에 넣은 함수를 `나중` 에 실행하는데 이를 `비동기식` 이라고 부른다. 함수 안에 넣은 함수가 항상 나중에 실행되는 것은 아니지만 그런 경우가 많다.
그런 경우에는 Node.js가 해당 함수를 바로 실행하지 않고 대신 코드를 처음 접했을때 `내부적` 으로 이벤트 리스너를 하나 추가한다.

`Node.js` 는 모든 리스너들을 내부적으로 관리한다.
현재의 경우에는 요청 분석이 완료되면 `req.on('end')` 이벤트가 자동으로 실행된다. 다음으로 실행 완료 후 해당함수를 대신 호출해준다.

즉, Node.js에 이벤트 / 이벤트 리스너가 적힌 명부가 있다고 생각하면 된다. 요청 분석을 완료한 후 명부를 보면서 요청을 다 처리했으니 이제 `end` 이벤트를 발송하려면 이벤트 리스너를 봐야겠다고 생각해서 해당 함수와 등록했던 다른 함수를 찾아 호출할 것이다.

> ✅ 하지만 다른 코드 실행을 분석하지는 않을 것인데, 이 개념이 중요하다

즉 만약 `writeHead, res.end` 가 이벤트 리스너안에 있다면 동작이 이상해진다는 것이다.
콜백함수를 등록한 후 다음 코드로 넘어간 다음에야 실행하게 되는데 그러면 너무 늦기 때문에 `cannot set headers` 오류가 나오게 되는 것이다.

이미 전부 진행되어 코드 실행도 했기 때문에 요청 분석이 끝난 후 다시 코드를 실행해서 응답을 발송하려고 한것이다.

#### 콜백

따라서 이전의 코드가 나중에 호출될 콜백이기 때문에 다음코드는 이전의 코드보다 먼저 실행될 수 있다. 이런 설정이 중요한 이유는 그렇지 않으면 `Node.js` 가 파일 작성 완료전까지 멈추게 되는데 그러면 서버가 느려지며 완료되기 전까지 들어오는 요청을 포함해 아무것도 처리할 수 없기 때문이다.

새로운 이벤트 루프를 기다렸다가 코드를 실행해야할때 실행하기를 원하지. 이벤트 루프를 너무 오랫동안 막기를 원하지 않으므로 이런 설정을 하는 것이다.

이벤트 리스너안에 req.end() 를 넣고 싶다면 req.on 이벤트 리스너 자체에 앞에 return 키워드를 넣어주어서 해당 부분이 실행되도록하고 하단 코드는 실행되지 않도록 해주어야 한다.
