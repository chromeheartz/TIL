## Node Basic

### 10. 블로킹 및 논블로킹 코드

---

### 📌 writeFileSync

`writeFileSync` 라인의 문제가 무엇일까?
`Sync` 키워드가 문제이다. `writeFile` 메소드도 있지만 현재는 동기화를 의미하는 `sync` 가 있는 메소드를 사용하였다. 이것은 이 파일이 생성되기 전까지 `코드 실행을 막는` 특별한 메소드이다.

이 파일들을 작업하는데에 `2가지 모드` 가 있는데,

- 파일이 완료될때까지 코드의 다음 라인이 실행되지 않도록 하는 `동기화 모드`
- 코드 실행을 막지 않도록 운영하는 `비동기화 모드`

짧은 텍스트의 경우 아주 빠르지만, 수백 메가바이트 이상의 큰 파일에서 이 방법을 적용하면 읽거나 복사하는 등의 상황에서 코드 실행을 막는 경우 다음 줄과 모든 코드가 파일 운영이 완료될때까지 실행을 멈출 것이며 다른 유저들이 보내어 새로 유입되는 요청들도 파일 운영이 끝나기 전까지는 취급되지 않을 것이다.

따라서 `writeFile` 메소드를 사용할것이다. 경로 / 데이터를 받아들일 뿐만 아니라 세번째 인수인 `콜백` 까지도 포함하기 때문에 이 방법이 더 낫다.
서버 생성때와 마찬가지로 이렇게 사용하게 되면 Node.js는 암묵적으로 이벤트 리스너를 등록시킨다.
해당 콜백에서는 오류 객체를 전달받는데 오류가 발생하지 않으면 공란으로 남아있겠지만 권한 누락을 비롯한 `어떤 오류가 발생` 한 경우라면 여기로 가져오게 된다.

```js
return req.on("end", () => {
  const parsedBody = Buffer.concat(body).toString();
  console.log(parsedBody); // message=4444
  const message = parsedBody.split("=")[1];
  fs.writeFile("message.txt", message, (err) => {
    res.writeHead(302, {
      Location: "/",
    });
    //   res.statusCode = 302;
    //   res.setHeader('Location', '/');
    return res.end();
  });
});
```

이 응답은 파일 작업이 완료된 경우에만 전송되어야 하기 때문에 `응답` 했던 코드를 위로 올렸다.
이제 이벤트 리스너와 함께 요청을 파싱하는 것이 끝난 뒤 실행하게 될 메소드 내지는 함수를 확보하게 되었으며 추후 언젠가 실행될 해당 함수 내부에도 또 다른 이벤트 리스너가 있고 중첩된 함수는 파일을 기록화는 과정이 끝난뒤에 실행될것이며, 이러한 과정은 Node.js에서는 `표준적` 이다.

#### 이벤트 드리븐 아키텍처

`이벤트 드리븐 아키텍처` 에서는 Node.js에게 작업을 진행하도록 지시하며 이후 해당 프로세스를 멀티 스레딩을 사용하는 운영체제에 전달하며 이벤트 콜백을 파악하기 위해 이벤트 루프를 계속하면서 코드 실행을 막지 않도록 그런 작은 조치들을 발송하고, 운영체제에서 작업이 끝난 뒤에는 항상 복귀하는 식의 구조를 지닌다.

이게 바로 Node.js의 구조이며 뛰어난 성능을 발휘하는 이유로 코드를 절대 막지않고 서버를 막는 일도 없고, 단지 계속해서 운영체제에게 `작업을 할당` 하고 완료된 뒤에는 돌아와서 콜백에서 응답을 전달하는 등의 작업을 진행하는데 이는 헤더 몇개만 진행하면 끝나는 작업이므로 전체 운영을 막는 일이 없다.

> ✅ `Node.js` 의 비동기적 특성으로 인해 이런 방법을 사용해야 한다.
