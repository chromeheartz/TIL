## Node Basic

### 11. Node.js 백그라운드 확인

---

### 📌 백그라운드

![](https://velog.velcdn.com/images/chromeheartz/post/0d0e1b0c-e618-41c8-b737-a2d4b08fbf10/image.png)

이벤트 루프라는 중요한 개념을 배웠다.
이제 Node.js가 코드를 정확히 어떻게 실행해서 계속 성능을 유지하며 파일을 다루는 등 오래 걸리는 작업을 수행하는지 더 자세히 알아보자.
실제로 무슨 일이 일어나는지 이해하는 것이 아주 중요하다.

`Node.js` 코드에 대해 꼭 기억해야 하는 것은 `하나의 Javscript 스레드` 만 사용한다는 것이다. 스레드는 쉽게 말해 운영체제에서의 프로세스로 하나의 스레드만 사용한다면 어떻게 요청을 다루는지 궁금할 것이다.

각 요청마다 스레드를 지정할 수 없으니 결국 모두 하나의 스레드에서 실행될것이고, 따라서 보안상의 문제가 제기될것이다. 또 성능을 이야기 할 때 가장 중요한 점으로 `요청 A를 아직 처리중 이라면 요청 B는 처리할 수 없는것인가` 하는 질문이 있다.
정답은 둘 다 처리할 수 있다

#### 성능

예를 들어 `fs` 라는 접근할 수 있는 코드가 있다. 보통 파일을 다루는 작업은 시간이 오래 걸리는데 파일의 크기가 아주 크고 꼭 바로 완료되는 것은 아니다. 따라서 들어오는 요청으로 파일을 다루고 있을 때 새로 들어오는 두 번째 요청은 아직 처리할 수 없기 때문에 기다려야 하거나 심지어 거부되기도 한다. 다시 말해 해당 사용자에 대해 웹페이지가 다운되는 것이다.

중요한 구조체인 `이벤트 루프` 는 Node.js가 시작하면 프로그램에 의해 자동으로 시작된다.
이벤트 루프는 `이벤트 콜백` 을 다루는데 `createServer` 에 추가했던 기능들이 이에 해당한다. 특정 이벤트가 일어났을 때 바로 이벤트 루프가 해당 코드를 실행하는 것이다. 모든 콜백을 파악하고 있어서 코드를 실행한다. 하지만 시간이 오래 걸리는 파일 연산에는 도움이 되지 않는다.

또 이벤트 루프는 연산을 다루지 않는다는 것을 알아야 한다. 오직 완성된 쓰기 파일에 정의한 콜백에 대한 코드들만 처리한다. 이런 코드들은 금방 처리할 수 있는 코드인데, 즉 이벤트 루프는 `빨리 끝낼 수 있는 코드를 포함한 콜백` 만을 다룬다.

대신 파일 시스템 연상등의 `오래 걸리는 연산` 은 `Worker Pool` 에 보내지고 이 역시 Node.js가 자동으로 시작하고 관리한다.
무거운 작업을 담당하는 워커풀은 말하자면 Javascript 코드로부터 완전히 분리되어 다른 `여러 스레드` 에서 작동할 수 있으며 앱을 실행하는 운영체제와 깊은 연관이 있다.

코드로부터 분리되었기 때문에 무거운 작업을 처리할 수 있는 것이다.

#### Worker Pool

워커풀의 워커가 코드, 요청 및 이벤트 루프와 분리된 상태에서 작업을 수행한다.
그렇지만 이벤트 루프와는 한 가지 연결점이 있다. 워커가 작업을 마치면 예를 들어 `파일 읽기` 를 마치면 읽기 파일 연산에 대한 `콜백` 이 시작되는데 이벤트 루프가 `이벤트 / 콜백` 을 책임지기 때문에 결국 이벤트 루프에 들어가게 될것이다.

거기서 `Node.js` 가 알맞은 콜백을 실행한다. 이렇게 배후에서 많은 과정이 일어나는 데에 아무런 코드도 내가 쓸 필요가 없다. 그냥 Node.js에 내장된 기능으로 코드를 작성하면 된다.

#### 이벤트 루프

![](https://velog.velcdn.com/images/chromeheartz/post/896b74eb-6327-404b-ab6c-a7306d36e58f/image.png)

결국 `이벤트 루프` 란 Node.js에 의해 실행되어 계속 실행하도록 하는 루프로 전에 `모든 콜백` 을 처리한다. 또 콜백을 처리하는 데에는 `일정한 순서` 가 있는데 루핑을 계속하는 루프로 새로운 반복이 시작될 때마다 실행해야하는 `타이머 콜백` 이 있는지 확인한다.
`setTimeout / setInterval` 이라는 메소드가 있는데, 타이머를 설정하면 타이머가 끝나면 실행할 함수를 Node.js가 알고 있어서 항상 새로운 루프 반복이 일어날때마다 시간이 다 된 콜백을 실행한다. 즉, 타이머가 끝난 콜백을 실행하는 것이다.

다음으로 다른 콜백을 체크하는데 예를 들어 `읽기 및 쓰기 파일의 연산` 이 끝나서 콜백이 있을 수 있는데 그런 콜백들(pending callbacks)를 실행한다.
여기서 말하는 `I/O` 란 입력 및 출력 연산으로 일반적으로는 파일 연산이지만 네트워크 연산인 경우도 있다 보통 오래 걸리는 `블로킹 연산` 을 가리킨다.

이 때 Node.js가 어느 시점에 이 단계를 떠나게 되는데 만약 아직 처리되지 않은 콜백이 너무 많이 있다면 루프 반복을 이어가는 대신 남은 콜백을 `다음 반복` 에서 실행하도록 미룬다.

이렇게 열린 콜백을 모두 처리하고나면 `Poll` 단계로 진입하는데 Node.js가 새로운 `I/O` 이벤트를 찾아 최대한 해당 이벤트의 콜백을 빨리 실행하도록 한다. 가능하지 않다면 실행을 미루고 대기 콜백으로 등록하게 된다.

또한 타이머가 다 되어 실행해야하는 콜백도 확인하는데 만약 있다면 `Times` 단계로 넘어가 바로 실행한다. 즉, 반복을 이어가지 않고 다시 돌아갈 수 있다.

만약 없다면 루프가 계속되는데 다음 `Check` 단계에서는 `setImmediate` 콜백이 실행된다. 이 콜백은 `setTimeout / setInterval` 처럼 바로 실행되기는 하지만 반드시 열린 콜백이 모두 실행된 다음에 실행된다. 보통 setTimeout보다 1ms만큼 빠르지만 현재 주기가 끝나거나 적어도 현 반복에 열린 콜백을 처리한 후에 일어난다.

그 다음은 `매우 이론적인 단계` 로 넘어간다. 이제 `닫힌 이벤트 콜백(close callbacks)` 들이 실행되는데 만약 닫힌 이벤트를 등록했다면 바로 이 시점에 해당 콜백을 실행한다.

> ✅ 정리하자면 `Timer Callback -> I/O관련 (Pending) Callback -> 다른 이벤트(Poll) 콜백 -> Check 콜백 -> Close Callback` 순서인것이다.

이렇게 된 다음 프로그램을 종료하는데 그 전에 등록한 이벤트 핸들러가 남지 않았는지 확실히 해야 한다. 그렇기 때문에 `refs==0` 으로 자료가 되어있는 것이다.
references나 ref로 숫자를 세는데 콜백 / 이벤트 리스너가 등록될 때마다 1씩 늘어난다.
특히 서버 환경에서 `createServer` 를 통해 서버를 생성하고 listen을 통해 들어오는 요청을 듣는 이벤트들은 기본으로 절대 끝나지 않는 이벤트 이기 때문에 refs는 항상 1이상일 것이다.

#### Javascript 스레드 관련

보안문제에 대해 살펴보자면 기본으로 아무 문제는 없을 것이다.
이후에 `글로벌 데이터 관리` 를 통해 요청A의 데이터가 요청B에 유출되지 않도록 하는 방법을 알아볼것이다. 기본으로 약간 분리되어 있는데 createServer의 콜백 메소드가 들어오는 새 요청마다 실행되고 또 해당 요청에만 실행된다는 뜻이므로 `요청 / 응답` 객체에 어떤 작업을 해도 유출되지 않는다. 즉, 각 기능의 범위를 다른 기능이 접근할 수 없고 Javascript 원리에 따라 기본으로 분리가 되어있는 것이다.
