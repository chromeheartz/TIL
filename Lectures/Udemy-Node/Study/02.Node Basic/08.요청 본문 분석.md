## Node Basic

### 08. 요청 본문 분석

---

### 📌 요청 본문 분석

요청의 일부인 데이터를 알아보자.
폼안에 있는 인풋에 입력하는 것이 데이터가 되는데 `req.data` 가 있을거라 생각하지만 그렇지 않고 대신 들어오는 요청이 `데이터 스트림` 으로 보내지는데 이는 Javascript가 일반적으로 알고 있는 구조체이며 Node.js에서 많이 사용된다.

#### 데이터 스트림

![](https://velog.velcdn.com/images/chromeheartz/post/6214b725-aff1-43ca-bd48-a3ba40e31491/image.png)

데이터 스트림은 무엇일까? 연관된 개념인 버퍼와 함께 알아보자.
들어오는 요청을 예로 들어보자.
`스트림` 은 `지속적인 프로세스` 이다. 노드가 많은 양의 요청을 한 `청크` 씩 읽고 어느 시점에 다 읽게 되는데 바로 이때부터 요청 전체를 읽기까지 기다리지 않고도 `각각의 청크` 를 다룰 수 있게 된다.

간단한 요청같은 경우에는 이 과정이 필요하지 않다.
입력 필드 데이터가 단 하나이므로 분석하는데 그리 오래 걸리지 않기 때문. 하지만 `업로드된 파일` 의 경우 상당히 오래 걸릴 수 있다.

> ✅ 이럴때는 데이터를 `스트리밍` 하면 `디스크` 에 쓸수 있기 때문이다. 즉, 데이터가 들어오는 와중에 앱이 실행되는 `하드 드라이브 / 노드 앱이 실행되는 서버` 에 쓸 수 있기 때문에 `파일 전체` 가 분석 완료되고 전부 업로드되기까지 아무것도 안하면서 기다릴 필요가 없다.

`Node.js` 는 요청이 얼마나 크고 복잡한지 미리 알지 못하기 때문에 이런 방식으로 처리하는 것이다. 하지만 데이터를 미리 다룰 수 있다.
문제는 코드를 사용해 청크를 마음대로 다룰 수는 없고, 대신에 들어오는 청크를 `체계화` 하기 위해 소위 말하는 `버퍼` 를 이용한다.

#### 버퍼

버퍼는 버스 정류장과 비슷하다. 버스는 항상 달리지만 사용자나 이 경우에는 승객이 버스에 타고 내릴 수 있으려면 버스를 찾기 쉽도록 버스 정류장이 있는데 그것이 바로 `버퍼` 의 역할이다.
여러 개의 청크를 보유하고 파싱이 끝나기 전에 작업할 수 있도록 한다.
실제 예를 한번 알아보자.

`POST` 메시지를 받을 때 응답을 보내거나 파일에 쓰기 전에 요청 데이터를 받아야 한다.
`req.` 를 입력해서 이벤트 리스너를 등록하면 되었는데, `on` 메소드를 사용하여 직접 특정 이벤트를 들을 수 있도록 할 수 있다.

![](https://velog.velcdn.com/images/chromeheartz/post/778d9909-c56e-49ba-a054-e34a8ae416bb/image.png)

여기서 `data` 를 입력하면 새 청크가 읽힐 준비가 될 때마다 데이터이벤트가 발생하는 데에 버퍼가 도움을 준다. 두 번쨰 인자로 `모든 데이터 이벤트에 실행될 함수` 를 넣어주어야 한다.
`on(data)` 를 호출하면 리스너가 데이터 청크를 받도록 `chunk` 를 입력한다.

이 청크를 사용해 무언가를 해야만 청크와의 상호작용을 만들 수 있다.
`const body = []` 로 빈 배열을 만들어놓고 여기에 `push` 로 청크를 넣어보자.

또한 `req.on('end')` 리스너를 등록해볼것인데, 들어오는 요청 데이터 혹은 들어오는 전반적인 요청을 분석한 후 발생한다.
여기에서도 두 번째 인수로 정의하는 함수를 실행할텐데, 이 함수는 읽어들인 모든 청크에 기반할 수 있다. 전역에서 사용 가능한 `Buffer 객체` 를 사용해 `concat(body)` 를 입력하면, 새 버퍼가 생성되고 본문 안에 있던 모든 청크가 추가될 것이다.
그리고 문자열로 전환하기 위해 `toString` 을 사용하면 된다.

`Node.js` 가 제공하는 메소드로 버퍼가 생긴 청크에 작업을 하는것이다.
버스 정류장에 버스가 기다리고있고, 버퍼가 버스정류장이며 버퍼를 문자열로 전환하는데 요청의 본문이 텍스트니 들어오는 데이터도 텍스트기 때문에 문자열로 전환할 수 있을것이다.
**📍 파일이라면 다른 조취를 취해야 함.**

```js
const body = [];
req.on("data", (chunk) => {
  console.log(chunk); // <Buffer 6d 65 73 73 61 67 65 3d 34 34 34 34>
  body.push(chunk);
  console.log(body); // [ <Buffer 6d 65 73 73 61 67 65 3d 34 34 34 34> ]
});
req.on("end", () => {
  const parsedBody = Buffer.concat(body).toString();
  console.log(parsedBody); // message=4444
  const message = parsedBody.split("=")[1];
  fs.writeFileSync("message.txt", message);
});
```

이렇게 하면 이제 파일에 입력을 저장할 수 있는 것이다.
하지만 이대로 실행해보면 `hello! -> hello%21` 이런식으로 작성이 되는데 이건 이후에 디코딩을 해주어야 한다.
