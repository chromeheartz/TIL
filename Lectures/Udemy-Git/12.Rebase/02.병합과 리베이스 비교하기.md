## Rebase

### 02. 병합과 리베이스 비교하기

---

### 📌 rebase로 할 수 있는 작업

앞서 말했듯이 `rebase` 로 할 수 있는 작업은 2가지가 있다.
먼저 `git merge 명령어 대용` 을 보자.

`merge / rebase` 모두 두 개의 브랜치를 하나로 병합하는 기능을 제공한다.
먼저, 머지 활용시 발생하는 문제를 어떻게 `rebase` 가 커버할 수 있는지 보자.

#### 1️⃣ 예시

만약 개발자 10명과 함꼐 프로젝트에 참여하고 있고, 꽤 큰 규모의 코드 베이스로 작업을 하고 있다고 가정해보자.
메인 브랜치가 있는데 커밋이 몇만개 있어서 일일이 볼 수도 없다. 이 때에 새로운 기능을 작업하게 되어 `feature` 라는 브랜치를 만들어 작업을 한다.
여기서 커밋을 한 두개 더 올리고 잠시 쉬고있는데 다른 동료가 `PR` 같은 경로로 main에 머지했다.
📍 결론적으로 `main에 변경사항` 이 생긴것

<img width="1020" alt="스크린샷 2024-09-19 오후 5 48 18" src="https://github.com/user-attachments/assets/3720c22b-09c0-43fe-af5a-c63b93103b9e">

이제 내 브랜치에 변경사항을 적용해야 하는데, 이때 동료의 커밋을 가지고 올 때 `merge` 를 할 수 있다.

이 때 `머지 커밋` 이 발생하게 된다. `원 테두리 색이 다르게 표시` 한 커밋을 봐보자.

<img width="1120" alt="스크린샷 2024-09-19 오후 5 49 20" src="https://github.com/user-attachments/assets/052ee9e6-37b3-4a95-a5f3-d3090a3d4fab">

하지만 만약 기능을 또 개발하던 도중에 `main` 에 변경사항이 생기면 계속 변경사항을 받아야 한다. `머지 커밋` 만 내 브랜치에 주렁주렁 달리게 되는것이다. 내 작업과 전혀 관련이 없는 커밋들.
📍 이것을 피할 방법은 없다.

또한 작업하면서 누구라도 메인에 코드를 반영하면 모두들 해당 코드를 `본인 피쳐 브랜치` 로 머지해야하고, 각자 가진 피쳐 브랜치에 `머지 커밋` 이 계속 남게 되고, 작업이 완료되고 `main` 에 머지를 하게 되면 `깃 히스토리` 에 무의미한 머지커밋이 남게 되어 지저분하게 만들 수 있다.

✅ 이런 문제를 `리베이스` 가 해결할 수 있다.

### 📌 rebase로 문제 해결

<img width="1147" alt="스크린샷 2024-09-19 오후 5 52 02" src="https://github.com/user-attachments/assets/fa50aa4b-a209-4a79-be14-e033fdb3b25a">
<img width="1175" alt="스크린샷 2024-09-19 오후 5 52 13" src="https://github.com/user-attachments/assets/8558b8fa-c030-42bf-a31e-3f079c5fdb20">

`rebase` 는 머지가 아닌 방법으로 브랜치를 병합하는데, 리베이스를 하면 ` 깃 이력` 을 재작성하기 대문에 `문제` 가 있다고 하기도 한다.

깃 이력을 재작성한다는 것은 피처 브랜치에 올려진 커밋을 `각각 새 커밋` 으로 생성하는 작업을 동반한다.

> 각 커밋이 생성된 순서를 의미하진 않고, 각 커밋마다 날짜 정보가 있고 이 정보는 보존되는데 `결과물을 위해 재배치` 된 것이라고 보면 된다.
> 즉, 내가 피처브랜치에서 올린 커밋들은 `메인 브랜치의 끝` 에서 시작하게 되는 것이다.

> **git rebase docs** 👉 [`git rebase docs`]

[`git rebase docs`]: https://git-scm.com/docs/git-rebase
