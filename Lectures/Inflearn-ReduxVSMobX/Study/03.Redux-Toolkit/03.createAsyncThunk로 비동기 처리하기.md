## Redux-Toolkit

### 03. createAsyncThunk로 비동기 처리하기
---------------------------------------------


### 📌 createAsyncThunk

```js
// actions/post.js
const { createAsyncThunk } = require('@reduxjs/toolkit');

const delay = (time, value) => new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(value);
  }, time);
})

exports.addPost = createAsyncThunk('post/add', async (data, thunkAPI) => {
  return await delay(500, data);
})
```

실제 서버가 없다보니 서버를 흉내내기 위해 `딜레이` 가 필요하다.
딜레이 함수를 만들어서 구현해놓았다. 이렇게 프로미스로 가짜 딜레이가 있다고 치면 `result` 는 500ms초 뒤에 데이터를 응답한다고 해줄것이다.

✅ 사실은 이메일, 비밀번호 이런것들을 서버쪽으로 보낸 다음에 응답을 받아서 오는 것. 그 시간을 구현했다고 가정

```js
// actions/user.js
const logIn = createAsyncThunk('user/logIn', async (data, thunkAPI) => {
  console.log(data);
  // const state = thunkAPI.getState();
  const result = await delay(500, {
    userId: 1,
    nickname: 'bibi',
  })
  return result;
  // data return
})
```

⭐️ 여기서 한가지 팁은 `Async Await` 에는 `Try Catch` 문을 함께 사용하는 것이 좋은데 `createAsyncThunk` 에서는 사용을 안하는게 좋다. 왜냐하면 `Try Catch` 로 감싸버리면 에러가 발생을 안하기 때문. 에러가 발생을 해야 `thunk` 가 `rejected` 상태로 가게 되는데, 에러가 없으면 무조건 성공상태 `FullFilled` 상태로 넘어가게 되는것이다.

#### `(data, thunkAPI)` 에서 data는 어디서 오는 것일까?

로그인을 실제로 가져다 쓸때에는 액션에서 가져와서 사용을 하게 되는데 즉, `dispatch(logIn({...}))` ... 부분이 data가 되는것이다.


