## Redux-Toolkit

### 06. 리덕스를 쓰지 말아야 할 때(비동기)

---

### 📌 리덕스를 쓰지 말아야 할 때(비동기)

컴포넌트에서만 쓰이는 것들 즉, `한 컴포넌트에서만 쓰이는 것들` 은 디스패치로 리듀서로 보내지말고 스테이트로 관리해서 `최종적` 으로 리듀서로 보내기로 했다.
✅ `비동기 요청` 도 마찬가지.

> `비동기 요청` 예를 들어 로그인 같은것이 컴포넌트 하나에서만 실행이되고 다른 컴포넌트에는 아예 영향을 끼치지 않는 것이 가능하다. 그럴거면 `비동기 액션` 으로 안만들고 해당 컴포넌트에서 `axios` 로 요청을 보내는게 좋다.

```jsx
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState(false);
const [done, setDone] = useState(false)

const onClick = useCallback(async () => {
  setLoading(true);
  setDone(false);
  setError(false);
  try {
    const response = await axios.post("/login");
    setDone(done);
  } catch(error) {
    setError(error;
  } finally {
    setLoading(false);
  }
}, []);
```

대신에 처리 할 때는 `리덕스` 랑 비슷하게 해야 한다.
`loading, error, done` 상태를 만들어서 각각 처리.

```jsx
const { createSlice } = require("@reduxjs/toolkit");
const { logIn } = require("../actions/user");

const initialState = {
  isLoggingIn: false,
  isLoggedIn: false,
  error: false,
  data: null,
};

const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    logOut(state, action) {
      state.data = null;
    },
  },
  extraReducers: (builder) =>
    builder
      .addCase(logIn.pending, (state, action) => {
        state.data = null;
        state.isLoggingIn = true;
        state.isLoggedIn = false;
      })
      .addCase(logIn.fulfilled, (state, action) => {
        state.data = action.payload;
        state.isLoggingIn = false;
        state.isLoggedIn = true;
        state.error = false;
      })
      .addCase(logIn.rejected, (state, action) => {
        state.error = action.payload;
      }),
});

module.exports = userSlice;
```

`userSlice` 에 구현을 한다고하면 이런 형태가 될것이다. `컴포넌트 하나` 에서만 요청을 보내고 그 다음에 다른 컴포넌트에 이 요청이 영향을 안 미치는 경우에는 그냥 `useCallback` 안에서 처리해버리는 게 낫다.
괜히 `한 컴포넌트` 안에서만 쓰이는데 `리덕스 비동기 액션` 으로 뺄 필요는 없을것이다.
