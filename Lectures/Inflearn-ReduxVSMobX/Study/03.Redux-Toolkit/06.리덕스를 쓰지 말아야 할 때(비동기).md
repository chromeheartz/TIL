## Redux-Toolkit

### 06. 리덕스를 쓰지 말아야 할 때(비동기)

---

### 📌 리덕스를 쓰지 말아야 할 때(비동기)

컴포넌트에서만 쓰이는 것들 즉, `한 컴포넌트에서만 쓰이는 것들` 은 디스패치로 리듀서로 보내지말고 스테이트로 관리해서 `최종적` 으로 리듀서로 보내기로 했다.
✅ `비동기 요청` 도 마찬가지.

> `비동기 요청` 예를 들어 로그인 같은것이 컴포넌트 하나에서만 실행이되고 다른 컴포넌트에는 아예 영향을 끼치지 않는 것이 가능하다. 그럴거면 `비동기 액션` 으로 안만들고 해당 컴포넌트에서 `axios` 로 요청을 보내는게 좋다.

```jsx
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState(false);
const [done, setDone] = useState(false)

const onClick = useCallback(async () => {
  setLoading(true);
  setDone(false);
  setError(false);
  try {
    const response = await axios.post("/login");
    setDone(done);
  } catch(error) {
    setError(error;
  } finally {
    setLoading(false);
  }
}, []);
```

대신에 처리 할 때는 `리덕스` 랑 비슷하게 해야 한다.
`loading, error, done` 상태를 만들어서 각각 처리.

```jsx
const { createSlice } = require("@reduxjs/toolkit");
const { logIn } = require("../actions/user");

const initialState = {
  isLoggingIn: false,
  isLoggedIn: false,
  error: false,
  data: null,
};

const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    logOut(state, action) {
      state.data = null;
    },
  },
  extraReducers: (builder) =>
    builder
      .addCase(logIn.pending, (state, action) => {
        state.data = null;
        state.isLoggingIn = true;
        state.isLoggedIn = false;
      })
      .addCase(logIn.fulfilled, (state, action) => {
        state.data = action.payload;
        state.isLoggingIn = false;
        state.isLoggedIn = true;
        state.error = false;
      })
      .addCase(logIn.rejected, (state, action) => {
        state.error = action.payload;
      }),
});

module.exports = userSlice;
```

`userSlice` 에 구현을 한다고하면 이런 형태가 될것이다. `컴포넌트 하나` 에서만 요청을 보내고 그 다음에 다른 컴포넌트에 이 요청이 영향을 안 미치는 경우에는 그냥 `useCallback` 안에서 처리해버리는 게 낫다.
괜히 `한 컴포넌트` 안에서만 쓰이는데 `리덕스 비동기 액션` 으로 뺄 필요는 없을것이다.

> ⭐️ 결국 정리하면 `하나의 컴포넌트 안` 에서 처리할 수 있는 것은 `redux` 보다 `useState, useCallback` hooks를 이용해서 처리하는 것이 좋다.

### 📌 비동기 요청들이 늘어나면 생기는 문제

```jsx
// loading, error, done
const [isLogInLoading, setIsLogInLoading] = useState(false);
const [isLogInError, setIsLogInError] = useState(false);
const [isLogInDone, setIsLogInDone] = useState(false);

const [isLogOutLoading, setIsLogOutLoading] = useState(false);
const [isLogOutError, setIsLogOutError] = useState(false);
const [isLogOutDone, setIsLogOutDone] = useState(false);

const [isJoinLoading, setIsJoinLoading] = useState(false);
const [isJoinError, setIsJoinError] = useState(false);
const [isJoinDone, setIsJoinDone] = useState(false);

// useSlice.js
const initialState = {
  isLoggingIn: false,
  isLoggedIn: false,
  isLoggingOut: false,
  isLoggedOut: false,
  logInError: false,
  logOutError: false,
  error: false,
  data: null,
};
```

비동기 요청들이 계속 늘어나게 되면 `loading / error / done` 이런것들이 게속 추가가 된다. 2개이상 생기게 된다면 `이름을 구별` 해야하는데 `[logInError, setLogInError]` 이런식으로 각각 상태를 만들어 이름을 만드는것도 귀찮은 부분이 생길것이다

각 3개씩 생기고 한 쌍이 생긴다면 3개씩 더 생긴다. 일단 너무 보기가 지저분해진다. 이런 상태일 때 문제가 되는 부분은 `같은 버튼을 계속 누르는 경우` 예를 들어, 로그인, 게시글, 다른것 이렇게 3개를 요청을 보내면 요청이 3개가 가는데 그 중에 뭐 하나는 실패하고 하나는 성공하고 하나는 실패하고 이런 경우에 `하나의 스테이트` 에 `3개의 요청` 을 담아내는 것이 어렵다.

#### 그러면 이런 것을 어떻게 해결해야 할까?

비단 컴포넌트의 스테이트에서만 발생하는 것이 아니라 `리덕스` 에서도 똑같이 발생한다.
이런 종류의 에러는 `redux / component` 둘 중 하나에서만 나는게 아니라 `리액트 단방향 특징` 때문에 `reaact / redux` 둘 다 에러가 난다. 이런 에러들을 어떻게 해결하는게 좋을까.

**✅ `[loadings, setLoadings]` 하나로 묶기.**

```js
const [loadings, setLoadings] = useState({});
const [errors, setErrors] = useState({});
const [dones, setDones] = useState({});
```

보통 이렇게 묶는데 결론은 `아래` 로 쭉 길어지거나 `가로` 로 쭉 길어지거나 그 둘 중에서 선택을 해야한다.
`배열 / 객체` 상관 없는데
