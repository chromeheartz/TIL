## Redux-Toolkit

### 07. createSelector(reselect)
---------------------------------------------

```jsx
const { email, password } = useSelector((state) => state.user);
```

기존에 `useSelector` 를 이런 `구조 분해할당` 형태로 사용하게 되면 쓸데없는 `리렌더링`  이 많이 일어날 수 밖에 없었다.

그래서 공식문서에서 나오는 하나의 해결책이 있는데

- `원시값 사용`
  - 객체만 나오는게 아니라 `원시값` 이 될 때 까지 따로쓰는것

```jsx
// 원시값 사용
const email = useSelector((state) => state.user.email);
const password = useSelector((state) => state.user.password);
```

하지만 이렇게 `모든 속성` 을 다 적어줄 수 없으니 보통 타협을 한다.  만약 딱히 최적화를 생각안하고 성능에 영향이 없을 것이라 생각하고 `{ email, password  }` 처럼 풀어서 사용하다가 문제가 생기면 어떻게 할까?
`원시값` 으로 하나하나 만들어도 되지만 `createSelector` 라고 `toolkit` 에서 제공하는 것이 있다.

### 📌 createSelector

기존에 `Reselect` 라고 유명했던 라이브러리를 `toolkit` 에 집어 넣은 것이다.

```jsx
// userSlice.js
const initialState = {
  isLoggingIn: false,
  data: null,
  email: '',
  password: '',
  data: null,
  prices: Array(100).fill().map((v, i) => (i + 1) * 100)
};

// app.jsx
const prices = useSelector((state) => state.user.prices);
<div><b>{prices.reduce((a, c) => a + c, 0)}원</b></div>
```

이런식으로 `prices` 라는 배열값을 가져와서 연산을 하는 함수로 값을 뿌려주고있는데 이렇게 되면 `email, password` 의 상태가 바뀔때마다 `리렌더링` 되며 계속 연산이 이루어지게 된다.

지금연산이야 간단하게 100개를 더하는 것이지만 연산이 더 복잡해질 수록 부하가 생길 수 밖에 없다.
이럴때 `캐싱` 을 해주어야 하는데 떠올리는 방법이 `useMemo` 를 써서 `memoization` 을 사용하는 것일것이다.