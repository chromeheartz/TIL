## MobX-React

### 06. computed와 MobX@6

---

### 📌 computed

예를 들어 게시글 작성하면 추가를 하는 코드를 짰었는데 만약 `data의 갯수` 를 가지고 오고싶다면 `{postStore.data.length}` 이런식으로 배열의 길이를 가져와서 사용했을 것이다.

하지만, `포인트 내역` 이 있고 전체 포인트를 더해야하는 연산이 있다고 가정해보자. 그런경우는 `컴포넌트` 가 리렌더링 될때마다 다시 연산을 해야할것이다.

`MobX` 를 사용하는 경우에는 `userStore` 의 데이터가 바뀔 경우에도 다시 리렌더링 되는 경우가 생길 수 있다. 즉, 외부 요인들이 리렌더링에 영향을 많이 미치게 된다.

연산이 복잡하면 복잡할수록 `MobX` 는 `캐싱` 을 제공하는데 그것이 ⭐️ `computed` 이다.

```js
const postStore = observable({
  data: [],
  addPost(data) {
    this.data.push(data);
  },
  get postLength() {
    return this.data.length;
  },
});
```

앞에 `get` 이 붙은 함수를 만들어주면 된다.
`get이 붙은 함수를 Getter` 라고 한다. 함수처럼 보이는데 `일반 속성` 같은 것이다.
이 속성에 만약 접근한다 하면 이 속성은 함수처럼 동작해서 주어진 내용을 수행.

#### 그럼 Setter도 있을까?

실제 앱에서 `value` 이 값을 대입하면 그 값을 매개변수로해서 받아진다.

```js
set post(value) {
  return this.data = value;
}
```

> 즉, `getter / setter` 는 선언은 함수처럼 하지만 실제로 쓸 때는 일반 값처럼 쓰는 신기한 함수
> ⭐️ getter는 MobX에서 `computed` 역할을 함.

미리 계산을 해놓고 데이터 `의존성` 이 바뀌기 전까지는 `캐싱` 을 하고 계속 같은 값을 쓴다.

`{postStore.postLength}` 사용할 때 이렇게 쓰는게 중요한게 `캐싱되어 있는 값` 을 그냥 그대로 가져온다. 따로 연산, 배열의 길이를 구하는 연산을 따로 하지 않고 그냥 저장되어 있는 값 그대로 가져온다.

✅ 그래서 웬만하면 연산이 복잡한 것들은 `get (computed)` 로 만들어 사용하면 된다.
