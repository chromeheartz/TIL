## 빅오 표기법 (Big-O-Notation)

### 03. 연산 갯수 세기
---------------------------------------------

### 📌 If not Time, then what?

코드를 `비교할 때` 시간을 비교하는 것은 문제가 있었다. 그럼 무엇을 사용해야할까?
비슷한 개념이지만 코드가 실행될 때 걸리는 `정확한 시간을 초로 측정` 하는 것보다는 컴퓨터가 `처리해야하는 연산 갯수` 를 세면 된다.

어떤 컴퓨터를 사용하든 `그 갯수` 는 변하지 않을것이다. 
시간은 항상 연산의 갯수에 달려있을 것이다. 

### 📌 Counting Operations

예시 코드를 보면 연산을 3번 해야한다. `N이 어떤 값을 갖고 있든` 상관없다. 
계산은 3번만 이루어질것이다. 

```js
function addUpTo(n) {
  return n * (n + 1) / 2;
  // 1 multiplication
  // 1 addition
  // 1 division
}
```

**기존에 보았던 해결법과 비교해보자.**

여기에는 연산이 몇개 더 있다. `+=` 를 연산 1번이라고 가정한다면 `Loop` 안에 있기 때문에 n이 5라면 5번 이루어질것이고, 20이라면 20번 연산이 이루어진다. 사실은 그것보다 더하다 `=` 도 있기 때문에.
`i++` 도 있고, 간단한 연산이 2개 있는데 N의 값대로 한번씩 늘어나게 된다. 
**즉, N이 커질수록 연산도 늘어남**
```js
function addUpTo(n) {
  let total = 0; // 1 assignment
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
  // iet i = 1 : 1 assignment
  // i <= n : n곱으로 비교가 이루어짐.
  // + : n additions
  // = : n assignments
  // i++ : n additions and n assignments
}
```

굳이 연산의 갯수를 새보자면 최소 `5n + 2` 번을 넘을것이다.

#### 이런식으로 모든 연산을 세는것은 쉽지가 않다.
정확한 숫자는 사실 상관 없다. `5n + 2` 이던 `3n` 정확한 값보다 `전체적인 추세` 를 보는것이 중요하고, 빅오를 볼때 이런것에 집중해야한다. 가장 중요한 것은 `큰 그림` 이다.