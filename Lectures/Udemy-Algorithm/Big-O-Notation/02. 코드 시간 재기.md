## 빅오 표기법 (Big-O-Notation)

### 02. 코드 시간 재기
---------------------------------------------

### 📌 문제

**1에서부터 특정한 N값과 사이에 있는 모든 값을 더하기**

1️⃣ 제일 쉬운 방법은 `for Loop` 를 사용해서 더해주는것이다.
1에서 시작해서 N까지 가고 루프를 할때마다 `total += i`

```js
// 02_addUpToSlower.js
function addUpTo(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
```

![스크린샷 2023-09-10 오전 10 21 31](https://github.com/chromeheartz/TIL/assets/95161113/b2445b27-0db1-4b2b-b294-fd845fa71045)

2️⃣ 루프가 사용되지 않는 수학 공식으로 함수 구현.

```js
// 02_addUpToFaster.js
function addUpTo(n) {
  return n * (n + 1) / 2;
}
```

![스크린샷 2023-09-10 오전 10 23 41](https://github.com/chromeheartz/TIL/assets/95161113/a532d5bd-a1ab-4dc1-8551-00e6b2b49fa5)


### 📌 "더나은" 것이 무엇을 의미할까?
- 더 빠르다는 것을 의미할까?
- 메모리를 얼마나 덜 사용하는지?
- 얼마나 쉽게 읽을 수 있는지? 

보통은 `속도, 메모리 사용` 에 포커스를 둔다. 이 두가지가 '코드를 얼마나 쉽게 읽을 수 있는지' 같은 다른것들 보다는 더 중요하다. 물론 코드를 쉽게 읽을 수 있도록 하는 부분도 중요하겠지만, 일단은 `속도` 에 중점을 두고 진행.

#### ⭐️ 코드 실행시간을 어떻게 평가할 수 있을까?

❗️ 가장 쉬운 방법은 `타이밍 함수`를 사용하는 것이다.

```js
var t1 = performance.now();
addUpTo(1000000000);
var t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)
```

작성해 놓은 `snippet1 / snippet2` 의 실행시간을 확인 해보면

![스크린샷 2023-09-10 오전 10 35 08](https://github.com/chromeheartz/TIL/assets/95161113/4dc07b2e-a328-4f84-8fc0-447853f14c6b)

`Slower` 는 시간이 계속 조금씩 바뀌며 그때 그때 다르게 나오지만 `Faster` 는 거의 동시. 측정된 값이 너무 작아서 0 seconds로 출력이 된다. 

### 📌 시간의 문제

현재는 `수동 비교` 를 했는데 이렇게 수동으로 타이밍을 구하고 서로 비교하는 것은 좋은 방법은 아니다.우선 기기마다 다른 방식으로 시간을 기록해서 믿을 수 없다. `기기 사양` 에 따라도 다를 것이고 같은 기기여도 조금씩 다른 시간이 기록 될 수 있다. 또한 정말 빠른 알고리즘에서는 `아주 작은 시간` 안에 처리가 되기 때문에 측정 속도 정확도가 정확하지 않을 수 있다.

만약 엄청 빠른 알고리즘 3개 정도가 있는데 구현해놓은 `타이밍 함수` 가 `작은 차이` 를 측정하기 어렵다면 도움이 되지 않을것이다. 

**코드를 살펴보면서 시간을 측정하지 않고 어떤 코드가 좋다고 평가할 수 있을까?**
이렇게 하지 않아도 코드를 비교하는 특정한 값이 있으면 좋겠는데 그 때 `빅오 표기법` 이 유용할것이다.