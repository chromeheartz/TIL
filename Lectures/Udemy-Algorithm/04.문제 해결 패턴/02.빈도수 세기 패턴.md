## 문제 해결 패턴

### 02. 빈도수 세기 패턴
---------------------------------------------

### 📌 Frequency Counters(빈도 카운터)

첫 번째로 살펴볼 패턴은 실제로 `빈도 카운터` 라고 불리지는 않는다.
공식 이름이 없는 것같은데 이렇게 부르는 이유는 이 패턴이 지닌 개념이 `보통 자바스크립트의 객체를 사용해서 다양한 값과 빈도를 수집` 하는 것이기 때문.

> ✅이 패턴은 `알고리즘` 과 과제에 있는 `여러 데이터 / 입력값` 이 서로 비슷한 값으로 구성되어 있는지, 서로 간의 관계가 있는지, 값이 다른 값에 포함되는지 여부 등을 비교하거나, 데이터를 입력값이나 두  개 이상의 빈도 혹은 특정하게 발생하는 빈도와 비교할 때 유용하다.

#### 📍 예시

`2개의 배열` 을 허용하는 `same` 이라는 함수를 만들고, 첫 번째 배열의 모든 값의 제곱이
`두 번째 배열` 에 해당하는 값을 가지면 `참` 을 반환하도록.
순서는 상관 없으니 동일할 필요는 없고 단지 제곱만 하면 된다.
섞일 수는 있지만 `값의 빈도` 는 동일.

```js
same([1, 2, 3], [4, 1, 9]) // true
same([1, 2, 3], [1, 9]) // false
same([1, 2, 1], [4, 4, 1]) // false (빈도수가 다름. 4가 2개있으면 안됨)
```

### 📌 코드 비교

#### ❗️ 순진한 해결책

해당 코드는 `순진한 해결책` 이다. 여기서 순진하다는 뜻은 `제곱 시간` 이 사용되면 순진하다고 표현한다.

이는 `중첩된 루프` 를 사용해서 
첫 번째 배열의 인덱스로 값에 접근해서 그 값의 제곱이 arr2에 있는지 `indexOf` 로 확인한다.

이 접근법에서 가장 먼저 수행할 작업은 `경계 조건이 괜찮은지 / 경계 조건이 아닌지` 를 확인하는 것이기 때문에 두 배열의 길이가 다른지 여부를 확인한다.

그 이후 루프를 이용해서 각 값의 제곱을 전달하는 위치에 `indexOf` 를 호출.
만약 값이 있다면 2번째 배열에서 해당하는 값을 뺀다(splice)

❗️ 이 기점에서 해당 함수는 제대로 일을 하고 있다. 
하지만 예를 들어 `4` 라는 수를 몇 번이나 찾았는지 횟수를 기억할 수 있는 방법이 필요하다.
또한, `4` 는 `2` 에 대하여 중복하여 적용할 수 없다.
따라서 `같은 빈도의 값` 이 있는지 확인해야한다.

이처럼 이 접근법은 `O(n^2)`. 즉, 제곱 시간이 사용
`indexOf` 는 전체 배열을 반복하거나 중첩된 루프인 전체 배열을 잠재적으로 반복한다.
따라서 `n` 이 배열 길이를 늘리면 이 값이 증가하여 2차 관계로 `중첩` 된다. 

```js
// naive solutions
function same(arr1, arr2){
  if(arr1.length !== arr2.length){
    return false;
  }
  for(let i = 0; i < arr1.length; i++){
    let correctIndex = arr2.indexOf(arr1[i] ** 2)
    if(correctIndex === -1) {
      return false;
    }
    // console.log(arr2); // 값이 줄어드는 것 확인
    arr2.splice(correctIndex,1)
  }
  return true;
}
```

#### ✅ 리팩토링

이 코드는 `빈도 카운터 패턴` 이 사용된 코드이다.
일단 첫번째 팁은 `두 개의 루프` 가 `두 개의 중첩된 개별 루프` 보다는 훨씬 낫다
- 두 개의 루프: n이 100일 경우 `n x 2 = 200` 번 반복한다.
- 두 개의 중첩 루프: n이 100일 경우 `100 x 100 = 10,000` 번 반복한다

결국 리팩토링 한 코드는 `선형 시간 O(n)` 이 되어서 기존 코드보다는 시간적으로 좋다.

#### 기본 개념 단계별로 살펴보기
- 1. 두 객체를 사용해서 각 배열의 개별 값의 빈도를 개수 `frequencyCounter1, 2`
- 2. 루프를 돌려 각 값을 객체에 개수
  - 각 값이 해당 배열에서 몇 번 나타나는지 알려주는 객체를 컴파일 하는 작업과 같다
- 3. 루프를 `한 번` 만 추가해서 둘 중 하나에만 적용. 현재는 `첫 번째 배열` 기준으로 작업

```js
// refactored
function same(arr1, arr2){
  if(arr1.length !== arr2.length){
    return false;
  }
  let frequencyCounter1 = {}
  let frequencyCounter2 = {}
  for(let val of arr1){
    frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1
  }
  for(let val of arr2){
    frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        
  }
  console.log(frequencyCounter1);
  console.log(frequencyCounter2);
  for(let key in frequencyCounter1){
    if(!(key ** 2 in frequencyCounter2)){
      return false
    }
    if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){
      return false
    }
  }
  return true
}

same([1,2,3,2,5], [9,1,4,4,11]) 
/*
  {1: 1, 2: 2, 3: 1, 5: 1}
  {1: 1, 4: 2, 9: 1, 11: 1}
  false
*/
```

> 적어도 이러한 `배열의 크기 증가` 에 따른 `빅O` 의 복잡성 측면에서는 리팩토링한 코드가 더 낫다.
알고리즘에 루프가 세 개 있는데 가장 큰 배열이 무엇이든 간에 3번 하게 되니 즉, 3n번 반복이 이루어질것이다. 

> ✅ `indexOf`
indexOf를 `중첩된 루프` 라고 말한 이유는 이 메소드의 기능 자체가 `중첩된 루프` 이다. 그저 shortCut 일 뿐이다. 최악의 경우 n이 1,000 이라고 가정할 때 1,000,000 번 작업이 이루어진다. 따라서 이런 방식의 작업은 훨씬 나쁘다.

⭐️ 이처럼 `빈도 카운터` 의 개념은 보통 `객체` 를 사용한다.
객체를 사용하여 프로파일을 구성하는 것은 배열이나 문자열의 내용을 분석하는 방법으로 보통 배열 / 문자열과 같은 `선형 구조` 를 구성하는 것이다.
그러면 해당 분석을 문자열이나 배열에서 생성된 다른 객체의 형태와 신속하게 비교할 수 있다.
따라서 두 개의 배열을 `객체로 세분화` 하여 각 배열의 요소들을 `분류` 한 다음 각 배열을 비교할 수 있다.