## 문제 해결 패턴

### 07. 고유값 세기 솔루션

---

### 📌 Solution

```js
function countUniqueValues(arr) {
  if (arr.length === 0) return 0;
  let i = 0;
  for (let j = 1; j < arr.length; j++) {
    if (arr[i] !== arr[j]) {
      i++;
      arr[i] = arr[j];
    }
  }
  return i + 1;
}
```

**풀이**

⭐️ 각각 0과 1의 위치에서 시작하는 `두 개의 포인터` 를 사용했다.
이어서 큰 값쪽으로 이동하면서 첫 번째 포인터를 특정한 조건, `일치하지 않는 두 개의 고유값을 찾는 경우` 에만 바꾸어 준다.

- 우선 함수를 정의, 배열을 받도록한 후에
  `i` 라는 변수를 만들고 `0` 으로 지정해서 인덱스 0부터 시작하도록

```js
function countUniqueValues(arr) {
  let i = 0;
}
```

- `for 루프` 를 만드는데 `1의 위치(index)` 로 설정한다.
  이렇게 구현하면 j는 배열의 1번 위치에서부터 전체 루프를 거쳐가게 된다
  ⭐️ 따라서 반복은 `한 번` 만 이루어진다

```js
for(let j = 1; j < arr.length; j++) {...}
```

- 반복문(루프) 내에서 `i, j` 배열의 각 위치를 비교하도록 해준다
  `두 배열이 서로 같지 않은지` 를 확인하여 조건문으로 만들어줌

```js
if(arr[i] !== arr[j]) {...}
```

- 그저 i와 마주하는 것과 다른 값을 찾을 때까지 j를 높은 값으로 이동시키면 된다.
  같지 않은 값을 만나게 된다면 i를 높은 값으로 이동시킨 다음 j에 있던 값을 i에 넣어준다.

```js
if (arr[i] !== arr[j]) {
  i++;
  arr[i] = arr[j];
}
```

- 현재 `모든 고유값` 을 포함하는 배열의 시작 위치를 완성하는 것까지 구현했는데,
  이제 이 부분의 길이가 필요할것이다.
  loop의 마지막의 `i, j` 를 보면 j는 배열의 `마지막 위치` 가 된다.
  ✅ 배열은 `정렬된 배열` 이여야만 한다.
  따라서 `i + 1` 으로 반환해주면된다. (i가 계속 이동해서 같은 값이 있는 마지막까지 옮겨지기 떄문)

```js
return i + 1;
```

- 마지막으로 빈 배열을 전달하면 작동하지 않고 1을 반환한다.
  i가 0에서 시작되고 아무 코드도 실행되지 않아서 `0 + 1` 로 1을 반환한다.
  따라서 `short circuit` 평가를 추가

```js
if (arr.length === 0) return 0;
```

이런식으로 구현하게 되면 `O(n)` 선형시간으로 적용이 되는 함수가 구현이 된다.

> ✅ **두 개의 포인터**
> 두 개의 포인터를 사용하여 구현했는데 개인적인 생각으로 각각 포인터들은 위치가 움직이면서 이동한다고만 생각했지 `i` 값같이 해당 위치에 값을 넣어서 평가할 생각은 조금 하기 어려웠다.
> 고유한 값을 저장하는 응용으로 배열을 바꾸는 방식을 활용하는 방법이 중요한 포인트가 되었다.
