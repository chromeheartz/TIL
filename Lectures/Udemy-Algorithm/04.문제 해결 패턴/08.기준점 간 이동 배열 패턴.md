## 문제 해결 패턴

### 08. 기준점 간 이동 배열 패턴

---

### 📌 슬라이딩 윈도우

`배열 / 문자열` 과 같은 일련의 데이터를 입력하거나 특정 방식으로 연속적인 해당 데이터의 `하위 집합` 을 찾는 경우에 유용한 `슬라이딩 윈도우 패턴`

#### 예시1: 가장 긴 시퀀스의 고유 문자를 찾는 함수

```js
"hellothere";
```

예를 들어 가장 긴 시퀀스의 고유 문자를 찾는 함수를 작성한다고 가정했을때 현재 문자열 기준으로 `hel` 의 경우에는 다음 `l` 때문에 시퀀스가 끊어진다. 일단 제일 긴 시퀀스일 텐데 그 후에 `lother` 가 나올 수 있으므로 해당 문자열이 가장 긴 고유 문자의 문자열이 될 것기앋.
이런 예시는 `슬라이딩 윈도우` 패턴으로 해결할 수 있다.

#### 예시2: 배열, 숫자를 전달하고 서로 마주한 두 숫자의 가장 큰 합계를 찾는 함수

```js
maxSubarraySum([1, 2, 5, 2, 8, 1, 5], 2); // 10
maxSubarraySum([1, 2, 5, 2, 8, 1, 5], 2); // 17
```

예를 들어 첫 번째 라인은 `2, 8` 두 번째 라인은 `2, 5, 2, 8` 값의 합이 반환되어야 한다.

#### 예시 2 작성

정수 배열과 n 이라는 수를 취하는 `maxSubarraySum` 이라는 함수를 작성해보자.
배열과 숫자를 전달하면 함수는 해당 배열의 `연속된 요소` 의 가장 큰 합계를 계산.
빈 문자열은 `null` 을 반환하도록

```js
function maxSubarraySum(arr, num) {
  if (num > arr.length) return null;
  let max = -Infinity;
  for (let i = 0; i < arr.length - num + 1; i++) {
    temp = 0;
    for (let j = 0; j < num; j++) {
      temp += arr[i + j];
    }
    if (temp > max) {
      max = temp;
    }
  }
  return max;
}
```

- 우선 각각의 경우에 숫자가 배열의 길이보다 큰지를 확인
  max를 만들어서 `-Infinity` 에서 시작되도록 한다. 배열이 모두 음수로 구성되어 있다면 가장 큰 합은 여전히 음수이기 때문.
  📍 양수로만 작업을 하지 않는 한 0에서 시작하는것은 도움이 되지 않는다.

```js
if (num > arr.length) return null;
let max = -Infinity;
```

- `num` 은 합계를 구하고자 하는 숫자의 개수. 그리고 `루프` 를 만든다.
  이 루프는 0에서 시작하고 `배열의 끝 / 거의 끝` 까지 도달하는데, 연속된 `n개의 숫자` 를 찾는경우 배열의 마지막 위치에서 중단되어야 한다.
  즉, 뒤에서 n개의 숫자까지

```js
for (let i = 0; i < arr.length - num + 1; i++) {...}
```

- `temp` 를 만드는데 0에서 시작하고, 여기에는 각 루프의 합계가 저장된다.
  따라서 `n개` 를 더하고 이 `n` 개를 max와 비교.
  이어서 다음 `n개` 를 더해서 현재의 `max` 보다 크면 max가 temp가 되도록 바꿔준다.

```js
for (let i = 0; i < arr.length - num + 1; i++) {
  temp = 0;
  if (temp > max) {
    max = temp;
  }
}
```

- 따라서 두 번째 루프는 j가 0이고 j가 num보다 작으면 `j++` 이 되도록한다. `num` 은 숫자의 개수

```js
for (let j = 0; j < num; j++) {
  temp += arr[i + j];
}
```

- 그 후 max 반환으로 마무리

```js
return max;
```

#### 이 해결책의 좋지 않은 점

> `중첩된 루프` 가 별 문제 아닌것처럼 보이지만,
> 만약 배열, 숫자가 크게 된다면 그 숫자만큼의 합계를 구하고 다음에 하나씩 이동하면서 그 숫자만큼의 루프를 또 적용하게 된다.
> 이런 방식은 아주 비효율적으로 작용한다.

⭐️ 이런 경우 `슬라이딩 윈도우 패턴` 이 유용하다.

### 📌 Sliding Window

`창문` 을 하나 만들어야 한다. 이 창문은 `단일 변수 / 하위 배열` 또는 필요한 경우 `다른 문자열` 도 될 수 있다. 조건에 따라 창문을 이동시키며, 시작 위치에서 시작하면 보통 `왼쪽 => 오른쪽` 으로 이동한다. 반대로도 가능하고 가운데 위치에서 시작할 수도 있다.
그러나 보통 `시작위치(왼쪽)` 에서 `끝나는 위치(오른쪽)` 으로 이동한다.

```js
function maxSubarraySum(arr, num) {
  let maxSum = 0;
  let tempSum = 0;
  if (arr.length < num) return null;
  for (let i = 0; i < num; i++) {
    maxSum += arr[i];
  }
  tempSum = maxSum;
  for (let i = num; i < arr.length; i++) {
    tempSum = tempSum - arr[i - num] + arr[i];
    maxSum = Math.max(maxSum, tempSum);
  }
  return maxSum;
}
```

시간 복잡도 `O(n)` 으로써 `선형 복잡도`

#### `작동 방식`

- 우선 첫 시작위치에서 합계를 구한다. 기존같이 합계를 구하면서 계속 진행하는 방식보다는 변수가 이 `합계` 를 지니도록 유지. `n개` 의 숫자의 다음 합계를 구하기 위해 수행해야 할 작업은 `그 다음 n개` 를 다시 더하는 것이 아니라 그저 `n개의 - 1개` 숫자만큼 빼고 마지막 숫자를 더하는 것이다.
  > ⭐️ 1개씩 다음 위치로 이동하기 때문에.
  > 예를들어
  > [1, 2, 3, 4, 4, 4, 5] 가 있고 num은 4라면
  > 처음은 `1, 2, 3, 4` 를 더하고 그 이후는 `2, 3, 4, 4` 를 더해야 하기 때문에
  > 시작한 위치의 값 1을 빼고 그 다음 숫자인 4를 더하는 것이다.
  > 다시 `2, 3, 4, 4` 를 더해서 비교하는 것이 아님.

결국에 여기서 포인트는
`죄다 다시 계산` 하는 것이 아닌 숫자를 뺀 다음 `창문` 을 다음 숫자로 이동시키고 숫자를 더하는것이다.

> **루프를 배열에 한 번만 적용할 수 있다**
> 따라서 배열에 숫자가 백만 개 있더라도 전체를 한 번만 살펴보면 된다.
> 중첩된 루프로 연속적으로 루프를 진행할 필요가 없고, 매번 루프를 통해 `한 번씩 뺄셈` 을 수행하면 된다.
