## 문제 해결 패턴

### 09. 분할과 정복 패턴

---

### 📌 분할과 정복

이 이름은 실제로 사용되는 `문서화` 된 패턴 이름이다.
`퀵 / 병합` 정렬은 `분할 정복 알고리즘` 의 예시들이며, `정렬 / 탐색` 으로 넘어가기 전에 먼저 살펴볼 것들이다. 마찬가지로 `이진 탐색` 또한 분할 정복 알고리즘이다.

### ✅ 분할 정복의 개념

이 알고리즘은 주로 `배열 / 문자열` 같은 큰 규모의 데이터셋을 처리한다.
`연결 리스트 / 트리` 가 될 수도 있다.
배열에서 값을 찾기 위해 `배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동` 하는 것보다는

> ⭐️ 배열을 `작은 조각으로 세분` 하여 각 조각들을 어디로 이동시킬지 결정하는 작업부터 한다.
> 즉, `큰 데이터 덩어리` 를 `작은 조각` 으로 나누는 것이다.
> 문제에 따라 큰 도움이 될 수 있지만 항상 그렇지는 않다.

#### 탐색 알고리즘 예시

이진 탐색 혹은 그냥 탐색이라는 알고리즘이 전형적인 예이다.

```js
search([1, 2, 3, 4, 5, 6], 4); // 3
search([1, 2, 3, 4, 5, 6], 6); // 5
search([1, 2, 3, 4, 5, 6], 11); // -1
```

이런식으로 호출하지만 사실상 `이진 탐색` 이라고 불린다.
함수에 `값` 을 전달하면 함수는 해당 `값` 이 있는 `위치(index)` 를 반환한다.
쉽게 해결하는 방법은 왼쪽부터 시작해서 숫자를 보고 해당 숫자가 아니라면 배열 끝까지 루프를 진행시키면 된다. 이렇게 하면 시간 복잡도는 `O(n)` 이 된다.

전체 배열을 훑어보고 `찾거나 못찾거나` 둘 중 하나이다.

❗️ `naive solution`

```js
function search(arr, val) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === val) {
      return i;
    }
  }
  return -1;
}
```

이 구조를 `선형 탐색` 이라고 한다.

✅ `Refactor`

```js
function search(array, val) {

  let min = 0;
  let max = array.length - 1;

  while (min <= max) {
    let middle = Math.floor((min + max) / 2);
    let currentElement = array[middle];

    if (array[middle] < val) {
      min = middle + 1;
    }
    else if (array[middle] > val) {
      max = middle - 1;
    }
    else {
      return middle;
  }
}
```

`이진 탐색` 은 약간 다른것을 지닌다.
정렬된 배열이니 `중간 지점` 을 선택하고 중간으로 잡은 값이 `val` 보다 큰지 작은지 확인한다.
만약 크다면 작은쪽은 배열에 없다는 것을 알고 있으니 무시하면 된다.
큰쪽의 `하위 배열` 을 보고, ,분할했으니 이제 `정복` 을 진행한다.

큰쪽의 배열들중에서 다시 중간을 선택하고 첫번째에 진행했던 방법을 동일하게 진행한다.
숫자를 계속 중간으로 쪼개다보면 값을 `찾을 수도 있고 못찾을 수도 있다`
처음부터 루프를 반복한다면 `n` 번의 단계가 필요한데 이때 `n` 은 배열의 길이나 최대 단계수가 될것이다.

> **분할과 정복 패턴**
> 이 패턴은 정말 보편적으로 사용되며 문자열에서 고유한 시퀀스를 찾는 것과 같은 작업이 아닌 더 `복잡한 알고리즘` 에 대부분 시간을 쓰게 될것이다.
