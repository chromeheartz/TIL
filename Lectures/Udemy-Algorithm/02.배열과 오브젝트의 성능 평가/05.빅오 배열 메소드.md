## 배열과 오브젝트의 성능 평가

### 05. 빅오 배열 메소드
---------------------------------------------

### 📌 Big O of Array Operations

**push - `O(1)`**
**pop - `O(1)`**
**shift - `O(N)`**
**unshift - `O(N)`**
**concat - `O(N)`**
**slice - `O(N)`**
**splice - `O(N)`**
**sort - `O(N * log N)`**
**forEach/map/filter/reduce/etc - `O(N)`**

`push / pop` - 배열 맨 끝에 추가하고 제거하는 작업은 무조건 상수 시간
`shift / unshift` - 모든 인덱스를 다시 정리해야하니 선형 시간

`concat / slice / splice` 는 전부 선형 시간이다.
- concat : 여러 배열을 합쳐주는 메소드. O(N) 이라고 하면 배열 하나에 있는 엘리먼트 갯수에 적용하는 작업이라고 생각할 수 있다. 하지만 2개라면 `O(N + M)` 여기서 M은 다른 배열의 크기라고 말할 수 있지만 `O(N)` 으로 단순화 한다.
  - 결국 결합할 배열이 커질수록 끝에 붙일 배열의 크기만큼 시간도 늘어날 것.
  
- slice : 배열 일부 혹은 전체를 가져오는 메소드. 10개 혹은 100개를 복사해서 가져올때 걸리는 시간은 `복사하는 갯수` 만큼 늘어나기 때문에 `O(N)`

- splice : 엘리먼트를 제거하고 추가하는 메소드. 배열 시작 혹은 끝에 추가하고 교체할 수 있다. 배열 중간에 추가하면 단순히 `O(N)` 이 되며 중간에 넣게 되면 shift를 해서 뒤에 있는 엘리먼트들을 다시 정리해야 한다. `O(N/2)` 라고 해도 그냥 `O(N)` 으로 단순화.

- `sort` : `O(N * log N)`. 현재 기점에서 sort에 대해서 딥하게 들어가지는 않을테니 배열의 메소드 중 제일 느리다는 것만 기억.

- `map / filter / reduce / forEach` : 엘리먼트마다 `한 가지 작업` 을 수행하고, 갯수를 기록, boolean으로 확인, 출력 등을 하는 작업은 엘리먼트마다 한 작업을 실행해야한다. 따라서 배열이 커질수록 걸리는 시간도 늘어난다. `O(N)`

> ✅ 배열을 정렬하는 것은 `O(N)` 보다 크다는 것만 기억하면 된다.
비교를 해야하고, 엘리먼트를 이동, 정렬 등을 하려면 조금 더 복잡해지게 된다.

> ⭐️ 객체와 배열을 보았을때 `가장 중요한 점` 은 객체는 거의 모든 것을 더 빠르게하지만, 정렬되어 있지않다. 배열은 정렬되어 있지만, 끝에 추가 혹은 제거하는 작업이 시작에 추가하고 제거하는 작업보다 훨씬 빠르다는것.
`시작` 에 넣거나 중간 등에 넣게 되면 그 자리에서부터 끝까지 영향을 받으며 `인덱스 재정리` 가 필요하다.