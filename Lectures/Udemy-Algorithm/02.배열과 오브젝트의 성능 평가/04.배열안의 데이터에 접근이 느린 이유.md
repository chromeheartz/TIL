## 배열과 오브젝트의 성능 평가

### 04. 배열안의 데이터에 접근이 느린 이유
---------------------------------------------

### 📌 Arrays

배열을 `빅오` 를 통해서 판단해보고 객체와 비교해보자.
배열의 가장 중요한 점은 `정렬이 되어 있다는 점` 이다. 데이터가 정렬되어 있는 기준이 있다. 한 뭉치로 되어있는 `객체` 와는 확연히 다르다.

물론 정렬 되어 있는 것이 필요하다면 유용하지만, `연산을 하는 시간` 이 더 걸릴 수 있다.

```js
let names = ["bibi", "2bobi", "barnes"];
let values = [true, {}, [], 2, "amazing"];
```

배열은 각각 엘리먼트마다 붙어있는 `인덱스` 가 있다. 

#### When to use Arrays

- 대부분 정렬되어 있는 데이터를 위해서 사용한다.
정렬되어 있는 것이 필요없다면 사용하지 않는것이 좋다. 섞여있는 데이터를 저장하고 싶을 때 배열을 사용해도 되지만 `성능 최적화` 의 관점에서 보면 다른 선택권이 있다.

> 정렬 되어 있는 것이 필요할 때, `싱글 링크드 리스트 / 더블 링크드 리스트` 처럼 코드안에 정렬된 구조가 있는 데이터도 있다.
`선형 리스트 구조` 로 엘리먼트마다 특정한 위치에 있고 순서대로 연결되어 있음.
하지만 때로는 하는 작업에 따라 배열보다 더 빠를 수 있다.
✅ 정렬되어 있는 데이터 구조가 배열만 있는 것은 아님.

- 정렬되어 있는 데이터가 필요할때 배열을 사용할 수 있지만 성능을 희생해야 할 수 있다. 입력 / 제거 시에 복잡해 질 수 있다.

### 📌 Big O of Arrays

**insertion - `It depends`**
**Removal - `It depends`**
**Searching - `O(N)`**
**Access - `O(1)`**

- `접근` 은 `O(1)` 으로 상수시간이다. 
만약 10000개의 엘리먼트를 가지고 있는 배열이 있는데 9000번째 엘리먼트를 요청했을때 앞의 9000번까지 숫자를 세면서 지나가는 것이라고 생각하면 안되고, `지름길` 이 있다고 생각해야 한다.
숫자, 인덱스가 있고 배열안에 존재하는 인덱스라면 그게 조건이 된다. 실제로 있으면 그 데이터로 바로 갈 수 있어서 `상수 시간` 이 걸리는 것이다

- `입력` 은 정렬되어 있는 것과 관계가 있다. 엘리먼트마다 붙어있는 인덱스가 있는데, 끝에다가 `push` 로 추가한다면 이런 작업은 `O(1)` 일테지만 `배열 맨 앞` 에 추가한다고하면 `인덱스` 들이 문제가 될 수 있다. 인덱스를 새로 배정해야 한다. 결국 `N` 의 크기에 따라서 커진다는 것이 핵심.

- `제거` 도 입력과 같은 문제이다. 어떤 값을 제거하면 인덱스를 `다시 배정` 해야 한다. 

- 탐색은 엘리먼트가 10000개 여도 중간에 있는 엘리먼트든 2번째 엘리먼트든 탐색하는 작업은 가장 빨라도 `O(N)` 이다.
정렬되어 있지 않은 배열을 말한다면 어떤 값이 포함되어있는지 확인하려면 모든 엘리먼트를 각각 확인해야 할 수도 있을것.


> 입력과 제거에서 무조건 첫 순서에 입력을 하는것을 하지 말라는 것이 아닌 `끝` 에서 추가하고 제거하는 것만큼 `효율적이지 않다는 것` 을 인지해야한다.
`push / pop` 작업이 `shift / unshift` 작업보다 빠르다. 비버있는 배열일때만 제외.
