## 배열과 오브젝트의 성능 평가

### 02. 객체의 빅오 (Big O)
---------------------------------------------

먼저 빅오와 성능 보는 관점에서 `객체` 를 볼것이다.
객체는 `정렬 되어 있지 않은 데이터 구조` 이다. 모두 `key value` 짝을 가지고 저장되어 있다.

```js
let instructor = {
  firstName: "bibi",
  isInstructor: true,
  favoriteNumbers: [1, 2, 3, 4]
}
```

#### When to use objects

- 객체는 `정렬 되어 있을 필요가 없을 때` 잘 작동한다
- 빠른 접근, 입력과 제거를 원할 때 좋다. 정렬 되어 있지는 않지만 다른 것들은 매우 빠르다

#### Big O of Objects

빠르다고 했을 때 입력, 제거, 접근 하는 시간이 `상수 시간` 이라는 뜻이다

**Insertion - `O(1)`**
**Removal - `O(1)`**
**Searching - `O(N)`**
**Access - `O(1)`**

#### 객체가 어떻게 작동하고 어떻게 저장될까?

만약 상단 객체 기준으로 `instructor` 라는 변수의 이름이 `"bibi"` 라고 저장한다면 자바스크립트가 실제로 어떤 작업을 할까?

컴퓨터는 그냥 `firstName` 이라고 적혀있는 `메모리 공간` 을 다시 접근할 수 있는것은 아니다. 그렇기 때문에 작업을 하면서 `추가적인 스텝` 들이 있는것.
> 현재 중요한것은 ⭐️ 자바스크립트가 어떤 정보를 `객체 안에 상수시간 안에 저장` 할 수 있다는 것이다. 원하는 내용 또한 `상수 시간` 안에 불러올 수 있다. 어떤 값을 상수 시간안에 수정할 수도 있지만, 그것이 결국 어떤 값을 불러오는 작업과 똑같다. 불러와서 바꾸기만 하는것이기 때문. 제거하는 것과 마찬가지

❗️ `기본적인 연산` 은 매우 빠르게 한다. 정렬이 되어 있지 않아서, 객체의 시작이나 중간, 끝 등에 입력할 수 없다. `단지 key` 를 사용해서 추가하는것

#### ✅ 입력, 제거, 접근까지 모두 상수 시간. 그러나 탐색은 선형 시간 이다.

탐색이라고 말하면 `key` 를 찾는 것이 아니다. 어떠한 정보를 접근하는 시간은 상수 시간이라고 말했다. `어떤 특정한 정보` 가 어떤 값에 있는지 확인하는것.

잠재적으로 `모든 아이템` 에 `모든 속성` 을 확인해야 할 수 있다. 
결국 N이 늘어날수록 그만큼 걸리는 시간도 늘어나게 된다.

### Big O of Object Methods

**Object.keys - `O(N)`**
**Object.values - `O(N)`**
**Object.entries - `O(N)`**
**hasOwnProperty - `O(1)`**

객체들과 따라오는 `메소드` 들을 보게되면 `key, values, entries` 는 모두 `선형 시간` 이다. 
아이템 갯수가 늘어나면서 `각 아이템을 접근` 해서 배열에 추가하는 시간이 늘어난다. 주로 N에 따라 시간이 변동한다. 2N, 50N일 수도 있지만 결국 `O(N)` 으로 단순화가 가능하다.

사실상 `entries` 는 작업이 조금 더 많다. 잠재적으로는 key, 그 값을 컴파일 해야하지만 결국은 `O(N)` 으로 정리할 수 있다.


```js
// Object.keys
Object.keys(instructor)
=> (3) ['firstName', 'isInstructor', 'favoriteNumbers']

// Object.values
Object.values(instructor)
=> (3) ['bibi', true, Array(4)]

// Object.entries
Object.entries(instructor)
=> (3) [Array(2), Array(2), Array(2)]
```


#### hasOwnProperty

왜 이 메소드만 `상수 시간` 일까?
일단 `키(firstName)` 이 있고, 그 값을 원하면 `상수 시간` 으로 이 정보를 접근할 수 있다. 그리고 똑같은 시간안에 `키가 존재하는지` 알 수 있다.

```js
instructor.hasOwnProperty("firstName")
=> true
```

> 앞으로 배열을 보게 된다면 배열이 빠를 수도 있지만, 정렬되어 있어 `작업에 따라` 느릴 수 있다. 그러나 객체는 간단하다. 어떠한 상황에도 작동하고 key / value가 모두 있고, 모든 연산이 모두 상수시간 이다.