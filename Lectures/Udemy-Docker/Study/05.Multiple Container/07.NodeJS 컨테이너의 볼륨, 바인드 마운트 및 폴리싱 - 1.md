## Multiple Container

### 07. NodeJS 컨테이너의 볼륨, 바인드 마운트 및 폴리싱 - 1

---

### 📌 바인드 마운트 및 폴리싱

이제 노드 백엔드에서 컨테이너가 작성하는 로그 파일에 데이터를 유지시키고 싶고, 실시간으로 소스 코드가 업데이트되게 하고싶다.

로컬 호스트 프로젝트 폴더에서 소스 코드를 변경하면, 컨테이너에서도 최신 코드를 사용할 수 있도록 하기 위해 일단 `goals-backend` 컨테이너를 중지.

다른 구성으로 백엔드 컨테이너를 시작할것인데, `두 개의 볼륨` 을 추가해보자.
로그 파일에 대한 하나의 볼륨이 필요한데, 명명된 볼륨으로 실행해서 호스트 머신에서의 저장 위치를 알 수 없지만 컨테이너 소멸에서 데이터가 살아남을 수 있도록 해보자. 또는 `바인드 마운트` 로 실행할 수 있고.

이것으로 호스팅 머신 내부에서 로그 파일을 읽을 수 있다.
컨테이너의 `/app/logs` 에 바인딩 해보자.
현재 `/app` 은 `Dockerfile` 에 지정된 작업 디렉토리고, 결국 이곳이 전체 애플리케이션이 복사되는 곳이다. 그리고 애플리케이션이 로그를 작성하는 `logs` 폴더가 있다. 따라서 로그가 기록되는 곳은 컨테이너 내부의 `/app/logs` 가 될것이고, 이것이 볼륨에 바인딩 하려는 경로가 된다.

#### 볼륨

`docker run --name goals-backend -v /Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/05-multi-starting-setup/backend:/app -v logs:/app/logs --rm -p 80:80 --network goals-net goal-node`

`logs:/app/logs` 이외에 볼륨이 하나 더 필요한데, 정확히 말하자면 `-v` 빌드로 생성한 바인드 마운트가 필요하다. `app` 폴더의 모든 것을 `로컬 호스팅 디렉토리` 에 바인딩하고자 하는데, `소스 코드` 에서 무언가를 변경할 때마다 확인하기 위해서.

이 모든것이 컨테이너 내부에 반영된다. 이제 이러한 바인드 마운트의 경우에 `폴더에 대한 전체 경로` 가 필요한데, 전체 경로를 이름 위치에 넣어 컨테이너 내부 경로인 `/app` 에 바인딩 하는것이다. 예를 들어, `app.js` 에서 `copy path` 를 하면 경로를 다 가지고 올 수 있는데, 그것을 붙여 넣으면된다. 단 마지막에 `app.js` 를 삭제 해야 한다.

> ✅ 백엔드에 대한 전체 경로를 붙여놓고 이를 컨테이너 내부 app폴더에 바인딩 하는 것이다.
> 더 긴 컨테이너 내부 경로가 우선하고, 더 짧은 내부 경로를 덮어쓴다.
> 따라서 logs의 예에서는 컨테이너에서 작성한 로그가 로컬 호스트 프로젝트 폴더의 로컬 logs 폴더로 덮어쓰여지지 않게 된다.
> (컨테이너 내부 폴더인 /app/logs 폴더가 명명된 볼륨내에 있을지도 모르는 동일 폴더에 의해 덮여쓰여지지 않는다. 더 구체적인 경로를 컨테이너에 명시했기 때문)

#### 정리

- `-v /Users/.../backend:/app` : 호스트의 로컬 디렉토리를 컨테이너 내부 경로에 그대로 연결한다. 호스트에서 코드 수정하면 컨테이너에서도 즉시 반영되게 하기 위해
- `-v logs:/app/logs` : `logs` 라는 이름의 볼륨을 Docker가 자동으로 관리하는 스토리지에 생성/사용한다. 컨테이너의 `app/logs` 파일에 연결되고, 컨테이너가 지워져도 유지된다.

📍 **부가 설명**

| 타입              | 호스트 경로                   | 컨테이너 내부 경로 |
| ----------------- | ----------------------------- | ------------------ |
| **바인드 마운트** | `/Users/bibi/.../backend`     | `/app`             |
| **명명된 볼륨**   | `logs` (Docker 내부 저장공간) | `/app/logs`        |

먼저 `/Users/bibi/.../backend` 가 `/app` 전체에 마운트 된다
그래서 컨테이너 내부 `/app` 에는 호스트 `backend` 폴더 구조가 그대로 복사된 상태처럼 보인다.

이후 `logs:/app/logs` 볼륨이 겹쳐서 마운트 되는데 이 때 `/app/logs` 경로는 기존 `/app` 마운트보다 경로가 더 구체적이기 때문에 **하위 경로가 우선 적용** 된다.

> `/app` 전체는 호스트 디렉토리에서 오지만,
> `/app/logs` 폴더 만큼은 `Docker 볼륨` 이 덮어씌운다.

#### 또 다른 볼륨

또한 `node_modules` 에 대해 유사한 작업을 수행해야 한다.
로컬 호스트 머신에 `node_modules` 가 없는 경우, 컨테이너의 기존 `node_modules` 를 로컬에 존재하지 않는 폴더로 덮어쓰지 말아야 한다.
그렇게 되면 컨테이너가 의존성을 찾을 수 없게 되어 충돌된다. 따라서 또 하나의 볼륨을 추가하는데 단순히 `익명 볼륨` 을 추가할것이다.

> 기본적으로 `app/node_modules` 를 가리키고, 컨테이너 내부의 기존 `node_modules` 폴더가 그대로 있어야 한다고 컨테이너에 알리고 우리가 `app` 폴더에 바인딩하는 호스트 시스템 폴더에 존재 하지 않는 `node_modules` 폴더로 덮어쓰면 안된다고 알린다.

`-v /app/node_modules` 를 추가해서 실행하자.

📍 최종
`docker run --name goals-backend -v /Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/05-multi-starting-setup/backend:/app -v logs:/app/logs -v /app/node_modules -d --rm -p 80:80 --network goals-net goal-node`

### 📌 nodemon

이제, 로컬 호스트 폴더의 최신 소스코드를 노드 컨테이너에 밀어 넣고있다.
하지만 현재로서는 그다지 도움이 되지 않는데, 컨테이너를 시작할 때 `node app.js` 를 실행하고 기본적으로 컨테이너가 시작되는 그 시점에 코드에 로그인 하기 때문이다.

노드 프로세스는 모든 코드를 로드한 다음 그 코드를 시작한다.
따라서 이후에 코드가 변경되더라도 `이미 실행 중인 노드 서버` 에는 영향을 미치지 않는다.
물론 코드가 변경될때마다 노드 서버가 다시 시작되기를 원하는데, 컨테이너를 중지했다가 다시 시작할 수 있다. 하지만, `nodemon` 을 추가해서 진행해보자.

`scripts` 섹션에 `start` 스크립트를 `nodemon app.js` 로 바꾸어준다. 이렇게 하면 프로젝트 폴더의 `JavaScript` 파일에 변경사항이 있을때마다 노드 서버를 다시 시작한다. 즉, `backend` 폴더에 변경사항이 발생할대 마다.
이후 `Dockerfile` 에서 `CMD` 를 `["npm", "start"]` 로 바꾸어준다.
`package.json` 을 바꾸었으니 다시 이미지를 빌드해야 한다.

이미지를 재빌드하고 컨테이너를 실행해보면, `console.log` 를 바꾸어보고 `docker logs goals-backend` 로 로그를 보면 변경사항으로 인해 재시작하는것을 볼 수 있다.

이제 바인드 마운트의 도움으로 노드 애플리케이션 `live code update` 를 제공할 수 있다.
