## Multiple Container

### 03. Node 앱 도커화

---

### 📌 Node 도커화

백엔드 도커화를 진행해보자.
backend폴더의 모든 것들을 컨테이너에 넣고자하는데, 이를 위해 프로젝트의 `자체 이미지` 를 빌드하는 `Dockerfile` 을 작성해야 한다.
`mongodb` 에서는 공식 이미지가 있었기 때문에 사용하지 않았다.

`node14` 버전을 사용하기 위해 `FROM node:14` 로 태그를 주었고, 작업 디렉토리인 `WORKDIR` 을 선택하는데 제일 자주 사용했던 `/app` 으로 진행해보자.
그 다음 `package.json` 파일을 작업 디렉토리에 카피하고, `RUN npm install` 명령으로 모든 요구 종속성을 설치한다.
그 다음, 호스트 머신 프로젝트 폴더의 나머지코드를 `컨테이너의 작업 디렉토리` 로 복사해주고, 애플리케이션에서 사용하는 포트도 `80` 을 노출해준다.
마지막으로 이 이미지를 기반으로 컨테이너가 시작될 때 실행되어야 하는 명령을 지정 `CMD ["node", "app.js"]`

```dockerfile
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 80

CMD ["node", "app.js"]
```

아주 기본적인 작업이다. 이것을 통해 이미지를 빌드할 수 있다.
`docker build -t goal-node .` `goal-node` 라는 이미지 이름을 지정해줘서 빌드.
자체 커스텀 이미지를 생성한 후에 이 이미지를 사용하여 백엔드에 대한 컨테이너를 구동할 수 있다.

`docker run --name goals-backend --rm goal-node`
처음에는 `detached` 모드로 실행하지 않아보자. 이렇게 실행하면 작동하는 것처럼 보이지만 충돌이 나는 것을 볼 수있다. `mongodb` 에 연결하지 못해서 충돌이 나는 것인데 여기에 많은 의미가 있다.

포트를 노출하는 컨테이너에서 실행 중인 `mongodb` 를 가지고 있고, 도커화된 백엔드 앱에서 로컬 호스트에 접근하고 있다. 현재 이 앱이 컨테이너 내부에 있으므로 동일한 컨테이너 내부의 포트에서 서비스에 액세스하려고한다.
⭐️ `호스트 머신` 에 접근하는게 아니라.

따라서 대체 도메인을 사용해야 하기 때문에 `host.docker.internal` 을 사용한다.
코드를 바꾸었기 때문에 리빌드하고 컨테이너를 실행해보자.
이렇게하면 연결되는것을 볼 수 있다.

백엔드는 컨테이너에 존재하며 mongodb와 통신할 수 있다.
하지만 여기서 새로운 문제가 있는데 `react` 가 이 백엔드와 통신할 수 없는것이다.

백엔드가 컨테이너에서 실행되는 동안 노출포트를 게시하지 않기 때문인데, 그래서 특정 포트에서 백엔드 앱과 통신하려는 프론트엔드가 실패하는 것이다. `EXPOSE` 명령은 사실 별 도움이 안되기 때문에 컨테이너를 실행할 때 로컬 호스트 머신에서 사용가능한 포트를 게시해야 한다.

일단 다시 `goals-backend` 를 중지시키고, 올바른 포트를 게시해보자.
`docker run --name goals-backend --rm -d -p 80:80 goal-node` 포트를 게시해서, 컨테이너에 의해 노출시키고, 애플리케이션이 컨테이너 내부에서 수신 대기 할 수 있도록 한다.

이렇게하면 프론트에서 백엔드와 통신할 수 있게 된다.
