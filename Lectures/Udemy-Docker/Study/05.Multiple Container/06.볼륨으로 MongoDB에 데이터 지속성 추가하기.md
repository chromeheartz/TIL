## Multiple Container

### 06. 볼륨으로 MongoDB에 데이터 지속성 추가하기

---

### 📌 볼륨으로 데이터 지속성 추가하기

이제 `mongodb` 컨테이너 작업을 시작해보자.
데이터가 거기에 지속되는지 확인하고 액세스를 제한한다.
`docker stop mongodb` 로 컨테이너를 중지 시켜주자.

이제 프론트에서 `goal` 을 추가해도 존재하지 않게 된다. `mongodb` 를 멈추면 컨테이너가 제거되기 때문에 저장된 모든 데이터가 손실되고 데이터베이스에 저장된 모든 데이터가 없어지게 된다.
따라서 데이터를 분리해야 하는데 결국에는 하드 드라이브에 기록되어야 한다.
또한 데이터베이스는 데이터가 컨테이너 `해체 및 제거` 후에도 살아남을 수 있도록 하드 드라이브의 어딘가에 데이터를 저장해야 한다.

`-v` 플래그로 볼륨을 추가해서, 이를 수행하도록 하자. `mongodb` 컨테이너가 데이터베이스데이터를 저장하기 위해 내부적으로 사용하는 경로를 알아야 하는데, `mongo` 라는 공식 이미지를 사용하기 때문에 내무적으로 어떤 경로가 사용되는지는 알 수 없다. 하지만 `mongodb` 컨테이너에 대한 문서는 살펴볼 수 있다.

`mongo` 공식 이미지의 문서를 보면, 데이터베이스 데이터. 즉, 컨테이너 내부에 데이터베이스 파일을 저장하는 곳은 `/data/db` 폴더이다. 바운드 마운트에 매핑되는 것도 알 수 있다.
![](https://velog.velcdn.com/images/chromeheartz/post/154dbd57-90ac-4fc8-ad87-d77e127d2856/image.png)

즉, 알고 있는 로컬 호스트 머신 폴더에 매핑된다는 것인데, 데이터베이스를 편하게 검사하는데 유용할것이다.
하지만 실제로 데이터를 유지하기 위해 그렇게 할 필요는 없다. 대신 해야 할 것은 `볼륨` 을 배울때 본것처럼 `명명된 볼륨` 을 사용하는 것이다. `data` 라는 이름을 붙이고 이것을 `/data/db` 에 바인드한다.

`docker run --name mongodb -v data:/data/db --rm -d --network goals-net mongo`

> ⭐️ 이것은 `바인드 마운트` 가 아니다.
> 로컬 호스트 머신 폴더에 대한 전체 경로가 없고, 그 대신 이름을 할당했다.
> 그런 다음 컨테이너 대신 경로에 매핑한다.

전에 보았듯이 도커는 볼륨이 존재하지 않는다면 볼륨을 생성하고 컨테이너 내부에 작성된 데이터를 호스트 머신 상에 어디에 있는지 모르는 호스트 머신의 볼륨에 저장한다. 그리고 이미 볼륨이 존재한다면 도커는 호스트 머신의 폴더에 있는 데이터를 컨테이너의 폴더로 로드한다. 그러면 데이터가 손실되지 않는다.
버전호환이 안맞아서 `docker volume rm data` 로 볼륨 데이터를 한번 지우고
`docker run --name mongodb -v data:/data/db --rm --network goals-net mongo:8.2.1` 로 mongo 이미지의 버전을 맞추어서 실행했다.

이제 다시 mongodb 컨테이너를 중지하더라도 살아남는다.
여기서 다시 컨테이너를 실행하면 새 컨테이너가 생성되는데, 웹 앱을 다시 로드하면 새 볼륨에도 데이터가 여전히 존재하는 것을 볼 수 있다. 이것이 `mongodb` 컨테이너에 남아있는 데이터이며 핵심 요구 사항중 하나이다.

#### 보안 / 데이터베이스 액세스 방지

이를 위해 `mongo` 이미지는 `두가지 환경 변수` 를 지원한다

- `MONGO_INITDB_ROOT_USERNAME`
- `MONGO_INITDB_ROOT_PASSWORD`

이러한 환경 변수를 사용할 때 컨테이너에 데이터베이스 삽입이 되어 그에 액세스하려면 `사용자 이름 / 비밀번호` 이 필요하게 된다. 이렇게 해놓으면 데이터베이스에서 액세스하려고 하는 컨테이너에서 이름 / 비밀번호를 지정해야 하므로 `부가 보안 레이어` 가 추가될 뿐이다.

일단 다시 mongodb 컨테이너를 중지하고 환경변수를 추가해보자.

![](https://velog.velcdn.com/images/chromeheartz/post/1d2cbb7e-db33-4f77-ac49-8ae37b710b30/image.png)

`docker run --name mongodb -v data:/data/db --rm --network goals-net -e MONGO_INITDB_ROOT_USERNAME=bibi -e MONGO_INITDB_ROOT_PASSWORD=0000 mongo:8.2.1`

이렇게 실행해보면 컨테이너는 실행중인데 `데이터 가져오기` 가 실패하는 것을 볼 수 있다.

![](https://velog.velcdn.com/images/chromeheartz/post/e9d60bba-eaba-4f64-b11c-24e006809b78/image.png)

mongodb와 통신하는 노드 앱이 사용자 정보 없이 연결하려고 했기에 실패한것이다.
그럼 `backend - app.js` 파일에서 수정해보자
데이터를 시작하는데 사용한 이름 / 비밀번호를 활용.

`connect` 부분을 수정할것인데, 이 문자열은 결국 `MongoDB` 가 이해하는 특수한 포맷을 가진다.
호스트 주소앞에 `사용자이름:비밀번호@` 형식으로 추가하면 된다.
`"mongodb://bibi:0000@mongodb:27017/course-goals",`
즉, 이런 형태가 될것이다. 코드를 바꾸었으니 이미지를 재빌드하고 다시 실행해보자.
그런데 백엔드 컨테이너에서 충돌이 발생한지, 작동하지 않는다. `MongoDB` 문서를 확인해보면 연결 문자열 끝에 `authSource=admin` 쿼리 매개변수를 추가해준다.
`"mongodb://bibi:0000@mongodb:27017/course-goals?authSource=admin",`

```cli
docker run --name mongodb -v data:/data/db --rm --network goals-net -e MONGO_INITDB_ROOT_USERNAME=bibi -e MONGO_INITDB_ROOT_PASSWORD=0000 -e MONGO_INITDB_DATABASE=course-goals mongo:8.2.1
```

약간 버전문제가 있었지만 mongo는 이렇게 올리고 문제가 있을때 `docker volume rm data` 로 한번 볼륨도 지우고 이미지, 컨테이너도 재실행했더니 잘 동작했다.
