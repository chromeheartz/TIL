## Multiple Container

### 05. 효율적인 컨테이너간 통신을 위한 Docker Network

---

### 📌 Network

`docker network create goals-net` 이라고 새로운 네트워크를 만들어보자.
이제 모든 컨테이너를 이 네트워크안에 넣어볼것이다. 그렇게 되면 더이상 포트를 게시할 필요가 없다. 컨테이너가 동일한 네트워크에 있으면 서로 통신할 수 있기 때문.

`docker run --name mongodb --rm -d --network goals-net mongo` 으로 mongodb를 실행해보자.
그리고 백엔드도 포트를 게시할 필요 없이 네트워크만 추가해주면 된다.

#### 이게 다일까?

백엔드 노드 애플리케이션은 `mongodb` 에 연결했었는데 `host.docker.internal` 에서 했기 때문에 자체 네트워크로 교체해야한다.`host.docker.internal` 은 로컬 호스트 머신을 참조한다.
이 포트는 더이상 사용할 수 없기 때문에 `app.js` 에서 코드를 수정해서 백엔드 컨테이너를 실행해야 한다.
connect `"mongodb://mongodb:27017/course-goals",` 되는 부분을 이렇게 바꾸어주고 이미지를 빌드한다.
`docker run --name goals-backend --rm -d --network goals-net goal-node`

이렇게 실행하고 `docker ps` 로 확인해보면 두 컨테이너가 모두 실행되고 있는 것을 볼 수 있다.
`react` 의 경우에도 마찬가지이다.
`const response = await fetch('http://goals-backend/goals');`

endpoint를 이런식으로 바꿔주어야 한다. 도커에서 노드 백엔드 컨테이너의 IP주소로 변환할 수 있기 때문.
따라서 이제 다시 이미지를 리빌드.
이미지를 리빌드 할 때 특히 `COPY` 단계가 꽤 오래 걸리는데, 이것 node_modules를 컨테이너에 다 복사하기 때문이다. 나중에 다시 최적화를 해보자.

일단은 이미지가 리빌드되면 컨테이너를 올릴때 동일 네트워크에 넣어야 한다.
⭐️ 그럼에도 불구하고 `포트` 를 게시하려고 하는데, 로컬 호스트 머신에서 이 앱과 상호작용하기를 원하기 때문이다. 브라우저에서 테스트할 수 있게 되는데 `--network goals-net` 도 추가해서 컨테이너는 동일한 네트워크의 일부이기도 하며 다른 컨테이너와 통신할 수 있어진다.

`docker run --name goals-frontend --network goals-net --rm -p 3000:3000 -it goal-react `
내 시나리오대로라면 이렇게 컨테이너를 올렸을때 문제가 없어야 한다.

```
App.js:17  GET http://goals-backend/goals net::ERR_NAME_NOT_RESOLVED
```

하지만 오류가 난다.

### 📌 여기서 문제가 뭘까?

여기서 `react` 가 어떻게 작동하는지를 알고 있고, 모든 프론트엔드 코드 즉 javascript 코드를 기억하고, 이해하는 것이 중요하다. 이 코드는 어떤 서버가 아니라 `브라우저` 에서 실행된다.
바로 이게 `백엔드 노드 코드` 와 비교되는 핵심적인 차이점이다

"mongodb://mongodb:27017/course-goals",
이것은 노드 런타임에 의해 컨테이너에서 직접적으로 실행된다.

`react` 의 경우에는 다르다 그저 `npm start` 만을 실행하는데, 이는 개발 서버를 시작하여 기본적은 리액트 앱을 제공한다. 하지만 리액트 코드는 컨테이너 내부에서 실행되지 않고 브라우저에서 실행된다.
그리고 이것은 `goals-backend` 로 지정해놓았던 엔드포인트 코드가 도커에 의해 `goals-backend` 로 변환될 수 있는 컨테이너에서 실행되지 않는다는 것을 의미한다.

브라우저는 `goals-backend` 가 무엇이 되어야 하는지 모르기 때문에 오류가 나는것이다.
따라서 컨테이너 이름을 사용하는 것은 단순한 옵션이 아니다. 이 코드는 도커 컨테이너에서 실행되지 않고 브라우저에서 실행되기 때문.
도커 컨테이너에서 실행되는 유일한 것은 애플리케이션을 제공하는 `개발 서버` 이다.

#### 그럼 무엇을 해야 할까?

일단 `localhost` 로 다시 되돌린다. 이게 로컬 머신과 통신할 수 있는 주소이기 때문.
브라우저가 이해하는 식별자로 바꾸고 엔드포인트에 도달할 수 있는지 확인해보자.`localhost/goals` 같은.
이는 단순하게 백엔드 애플리케이션에 `포트 80` 을 게시해야 함을 의미한다. 따라서 프론트엔드 앱은 로컬 호스트에서도 계속 사용할 수 있다 앱이 접근할 수 있으니.

`react` 는 도커 컨테이너 내부에서 실행되는 코드가 아니라 브라우저에서 실행되는 코드가 있기 때문에, 노드 앱과 통신해야 하는 노드 앱이 있다면 `컨테이너 이름` 을 사용할 수 있다.
하지만 브라우저에서 실행되기 때문에 브라우저가 이해할 수 있는 코드를 사용해야 한다.

이미지를 리빌드하고나서 `--network` 옵션은 필요하지 않다.
컨테이너에서 실행되는 부분인 개발 서버는 네트워크를 신경쓰지 않기 때문. 개발 서버는 `노드 API / database` 와 상호작용하지 않는다. 그리고 API와 상호작용하는 부분은 도커 환경에서 실행되지 않는다. 따라서 네트워크를 추가할 필요가 없는것이다.

이제 백엔드 컨테이너를 시작한 터미널에서 컨테이너를 중지 시키고 `포트 80` 을 게시해야한다.
mongodb와 통신하기 때문에 네트워크는 필요하다.
`docker run --name goals-backend --rm -d -p 80:80 --network goals-net goal-node`

이제 리로드해보면 정상적으로 작동하는 것을 볼 수 있다.

> ✅ `react` 가 조금 까다로웠다. 코드가 컨테이너에서 실행되지 않고 브라우저에서 실행되기 때문.
> 그러면 도커는 `자동 호스트 IP 변환` 을 도와줄 수 없다.
