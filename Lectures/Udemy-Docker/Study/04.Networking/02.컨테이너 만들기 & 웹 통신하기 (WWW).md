## Networking

### 02. 컨테이너 만들기 & 웹 통신하기 (WWW)

---

### 📌 웹 통신하기(WWW)

일단 도커화를 해서 컨테이너에 담아보자.
`Dockerifile` 이 기본적으로 구현되어있는데

```Dockerfile
FROM node

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

CMD ["node", "app.js"]
```

기본적으로 되어있다.
그렇기에 여기서 `docker build` 를 실행하여 이미지를 빌드할 수 있다.
`docker build -t faborites-node .` 로 빌드를 해보자. 이렇게하면 이미지가 만들어지는데
컨테이너의 이름을 `favorites` 로 지정하고 `detached` 모드로 실행하고 종료되면 자동으로 제거한다. 또한 포트를 게시해야만 하는데 `localhost:3000` 으로 포트와 작업하며 3000포트를 사용하기 때문에, 여기서 환경변수를 사용할 수도 있지만 일단은 간단하게 하드코딩으로 진행

현재 볼륨이 필요하지 않다. 왜냐면 앱에서 컨테이너 종료 및 제거에서 살아남을 파일에 아무것도 쓰지않고, 데이터베이스에 저장된 데이터를 제외하고는 살아남아야할 데이터가 없다.
`그 데이터베이스는 현재 이 컨테이너의 일부분이 아니다.`
이 컨테이너는 노드 앱과 그에 속한 코드만을 포함한다.

`docker run --name favorites -d --rm -p 3000:3000 favorites-node`
하지만 이렇게 하고 `docker ps` 로 확인해보면 컨테이너가 없다.
`-d` 모드로 분리되지 않게 시작해보면 오류 메세지와 함께 충돌이 나는것을 볼 수 있다.
`Mongo` 네트워크 오류인데, 연결이 실패한것이다.

당연히 여기서 문제가 발생한다.
`호스트 머신` 에 연결하지 못했다는 의미인데, 왜냐면 `MongoDB` 자체가 호스트 머신에서 실행되고 있기 대문이다.
일단 이를 해결하기 전에 `HTTP` 요청을 다른 웹사이트로 보내는 것이 제대로 작동하는지 보기 위해

```js
app.listen(3000);
// mongoose.connect(
//   'mongodb://localhost:27017/swfavorites',
//   { useNewUrlParser: true },
//   (err) => {
//     if (err) {
//       console.log(err);
//     } else {
//       app.listen(3000);
//     }
//   }
// );
```

이런식으로 데이터베이스에 연결하지 않고 해보자. 이미지를 리빌드하고 컨테이너를 실행하면 컨테이너가 실행하고 있는 것을 볼 수 있다.
데이터베이스에 연결하는것이 없기 때문에 앱의 일부분은 당연히 작동하지 않는다.
`movies / people` 엔드포인트는 더미 API에 접근하기 때문에 제대로 작동한다.

![](https://velog.velcdn.com/images/chromeheartz/post/ed2530e1-147c-4d6d-99eb-43e5c5770af2/image.png)

컨테이너에서 실행되는 API를 사용하고 있는데, 그 컨테이너는 노출된 포트 3000을 사용중이다.

#### 여기서 중요한 의미가 있다.

기본적으로 컨테이너는 `WWW(월드 와이드 웹)` 에 요청을 보낼 수 있다.
도커화된 애플리케이션 내부에서 웹API 및 웹 페이지와 통신할 수 있다. 특별한 설정이나 코드 변경이 필요하지는 않고, 그냥 작동한다.

도커화된 애플리케이션 내부에서 HTTP요청을 보내는 것이 작동한다.
심지어 컨테이너나 도커 없이도 작동하는 것이다.

> ✅ 따라서 컨테이너 내부에서 WWW로 요청을 보내는 것은 작동한다. 특별한 설정 없이
