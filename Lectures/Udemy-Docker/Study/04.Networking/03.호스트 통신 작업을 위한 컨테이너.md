## Networking

### 03. 호스트 통신 작업을 위한 컨테이너

---

### 📌 호스트 통신 작업을 위한 컨테이너

로컬 호스트 머신에서 실행되는 서비스나 서버로는 `HTTP` 요청을 보내는게 동작할까?

```js
mongoose.connect(
  "mongodb://localhost:27017/swfavorites",
  { useNewUrlParser: true },
  (err) => {
    if (err) {
      console.log(err);
    } else {
      app.listen(3000);
    }
  }
);
```

이제 도커화된 애플리케이션이 로컬에 설치된 `MongoDB` 데이터베이스와 통신할 수 있는지 확인해보자.
MongoDB는 로컬머신에 있는데, 즉 컨테이너가 아니라 `로컬` 컴퓨터에 있고, 노드 앱은 `컨테이너` 에 있다. 그리고 코드가 작동하지 않는다는 것을 보았었는데, 어떻게 하면 작동하게 할 수 있을까?

컨테이너를 시작하는 방법이나 코드에 대해 무언가를 변경해야 한다.
그리고 도커화된 애플리케이션. 즉, 도커화된 컨테이너의 코드와 로컬 호스트 머신과의 통신.
`"mongodb://localhost:27017/swfavorites",`
그러한 통신을 위해 해당 부분의 코드를 변경하기만 하면된다. 컨테이너를 다르게 시작할 필요가 없다.

코드 내에서 도커에게 주는 특별한 힌트가있는데, 이들 요청에 사용할 수 있는 특별한 주소가 있다.
`localhost` 를 도커가 이해할 수 있는 특별한 도메인으로 대체해야 한다

> ✅ `host.docker.internal`
> 이 특수 도메인은 도커에 의해 인식되고 이해된다. 그리고 도커 컨테이너 내부에서 알 수 있는 `호스트 머신의 IP 주소` 로 변환된다. 도메인이 필요한 곳, URL이 필요한 곳, 어디에서나 사용할 수 있다.

현재는 `mongodb` 타입의 요청을 위해서 사용하는데, HTTP요청에도 사용할 수 있다.
`"mongodb://host.docker.internal:27017/swfavorites",`

컴퓨터에 실행중인 특정웹서버가있고, 내 코드가 그것과 통신하는 경우에는 언제든 사용가능한것이다.
내부적으로 이 특수한 명령은 컨테이너 내부에서 볼 수 있는 `로컬 호스트 머신의 IP주소` 로 변환된다.
다시 이미지를 리빌드하고 컨테이너를 실행해보자.

로컬 호스트 머신에 MongoDB가 설치되어있다면 성공적으로 통신하고 있을것이다.
이 데이터베이스는 현재 컨테이너에서 실행되지 않고, 호스트 머신에서 실행되고 있다.
따라서 모든 데이터가 당연히 생존되어있는데, 이는 도커화된 앱 내부에서 호스트 머신으로의 통신이 `특수 도메인` 으로 가능하다는 것을 증명한다는 셈이다.

> ✅ 도커화된 앱에서 호스트 시스템으로의 `두번째 통신 타입` 이다.
> 즉, 컨테이너에서 호스트머신으로. 작동하지만 `host.docker.internal` 을 URL. 도메인으로 사용해야하고, 그러면 도커는 필요한 모든 변환을 수행하고, 컨테이너와 호스트 머신간의 통신을 보장한다.
