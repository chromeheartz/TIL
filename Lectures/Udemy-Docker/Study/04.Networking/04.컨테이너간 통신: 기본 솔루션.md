## Networking

### 04. 컨테이너간 통신: 기본 솔루션

---

### 📌 컨테이너간 통신

컨테이너와 컨테이너간의 통신을 알아보자.
이를 위해서는 먼저 두번째 컨테이너가 필요하다. 항상 한개만 작업해왔는데 이제는 `노드앱용 / MongoDB데이터베이스용` 컨테이너를 만들어보자.

앞서 언급했듯이 `모든 컨테이너는 한가지에만 집중` 하도록 하는 것이 좋다.
따라서 노드 웹 API용 컨테이너 / 데이터베이스 컨테이너가 필요하다.

이제 로컬에 설치된것을 사용하지 않고, `MongoDB` 데이터베이스를 컨테이너 안으로 넣어보자.
이제 컨테이너 내부에 MongoDB를 설정할것인데, 그것은 두 개의 컨테이너를 사용한다는 것을 의미한다.

만약 여기서 새로운 컨테이너를 만들려면 `다른 Dockerfile` 을 작성할것이라 생각하지만,
`docker mongodb` 를 검색하면 공식이미지가 있기 때문에 이미지를 기반으로 컨테이너를 실행하면 된다
즉, `docker run mongo` 를 실행하면 mongo라는 공식 이미지를 사용한다.
이 이미지를 기반으로 새 컨테이너를 생성하게 되는것이다.
![](https://velog.velcdn.com/images/chromeheartz/post/ed5d9448-a155-4bc0-99d8-d144d0deba8e/image.png)

현재 실행중인 MongoDB 데이터베이스 컨테이너이다.
이것은 터미널을 차단하고 있기 때문에 `-d` 를 실행하고 `--name` 으로 이름을 지정하여 컨테이너를 다시 올려보자.

그리고 NodeJS 앱의 코드를 변경해야 한다.
상위 컨테이너에서 실행중인 데이터베이스에 연결할 수 있도록. 일단 `host.docker.internal` 은 더이상 작동하지 않는다. 왜냐면 이건 다른 컨테이너의 IP주소가 아닌 `로컬 호스트 머신의 IP주소` 를 참조하기 때문이다.

그 대신 다른걸 할 수 있는데 `docker container inspect` 로 mongodb 컨테이너를 검사해보자.

![](https://velog.velcdn.com/images/chromeheartz/post/23b460de-50af-4c4e-9133-ccfd77817a46/image.png)

여기에 `NetworkSettings` 에서 IPAdress가 있는데, 이것이 컨테이너의 IP주소이다.
이 IP주소를 사용해서 컨테이너에 연결할 수 있다.

`host.docker.internal` 대신에 복사한 IP주소를 사용한다.
그러면 이 노드 앱은 다른 컨테이너와 그곳의 MongoDB데이터베이스에 연결된다 `27017` 은 디폴트 포트라서 변경할 필요가 없다.

이제 favorites-node 이미지를 다시 빌드하고 컨테이너를 실행해보자.

![](https://velog.velcdn.com/images/chromeheartz/post/307563c4-1158-4158-9ef2-042badd96c98/image.png)

컨테이너가 제대로 실행되고,
![](https://velog.velcdn.com/images/chromeheartz/post/a4e986d9-e7c6-4620-90a2-cea1c93e9b55/image.png)
요청도 제대로 들어가는 것을 볼 수 있다.

이는 더이상 `로컬 호스트 머신` 의 데이터베이스가 아니라 mongodb 컨테이너에 있는 새로운 데이터베이스이다.
그러므로 로컬 호스트 mongodb 데이터베이스에 저장된 데이터에 액세스할 수는 없다.
완전히 별개의 격리된 데이터베이스이기때문.

> ✅ 결국 분리와 격리는 도커의 핵심 개념이자 도커를 사용하는 핵심적인 이유이다.

여기서 번거로운건 컨테이너를 사용하기 위해 IP주소를 찾아야했고, mongodb 컨테이너의 IP주소가 변경될 때마다 매번 새 이미지를 빌드해야 한다.
노드 앱에서 IP주소를 하드코딩하기 때문.

하지만 다중 도커 컨테이너가 더 쉽게 통신하도록 하는 방법이 있다.
