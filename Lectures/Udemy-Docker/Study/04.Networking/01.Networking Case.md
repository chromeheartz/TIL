## Networking

### 01. Networking Case

---

도커화하려는 대부분의 애플리케이션에서 필요한것인데, 컨테이너 내부에서 네트워크를 사용하는 방법이다. 네트워크를 사용하여 다수의 컨테이너를 연결하는 방법 / 컨테이너가 서로 통신하게 하는 방법 / 컨테이너에 실행 중인 애플리케이션을 로컬 호스트 머신에 연결하는 방법을 알아보자.

### 📌 case 1: WWW 통신 컨테이너

![](https://velog.velcdn.com/images/chromeheartz/post/beed64dc-14dd-45f7-8490-98d32ba9ff51/image.png)

네트워크와 요청이 의미하는 바를 알아보자.
일단 애플리케이션이 포함된 컨테이너가 있다고 가정해보자. `Node / Python / ...` 어떤 애플리케이션이 될 수도 있다. 이제 이 애플리케이션이 로직의 일부로 `API` 즉, 월드 와이드 웹 내의 웹사이트와 통신하려고한다고 가정해보자.

예로, 그곳으로 데이터를 보내거나 데이터를 가져오려고 한다는 것이다. API 웹사이트는 내가 소유한 것이 아니라, 또 다른 컨테이너나 그와 유사한 것이 아니라 애플리케이션이 통신할 수 있는 웹사이트. 즉, `웹 API` 일 뿐인것이다.

`some-api.com/` GET HTTP 요청을 API에 보낼 수 있는데, 따라서 이 시나리오는 컨테이너에서 요청을 보내는 것이다. 컨테이너에서 실행되는 애플리케이션에서 `월드 와이드 웹` 으로 보내는것이다.
`04-NETWORKS-STARTING-SETUP` 예제 프로젝트를 한번 확인해보자.
`app.js` 를 보면 `Axios` 를 사용하고 있고, 그 종속성 또한 언급되어있다.
`const response = await axios.get('https://swapi.dev/api/films');`
`Star Wars API` 에 `get` 요청을 보내기 위해 Axios를 사용하고 있는것이다. 거듭 말하지만 `API` 는 내가 만든것이 아니고, 내 소유도 아니며 도커 컨테이너가 아니다.
단순히 더미 API라고 할 수 있다.

> ✅ 일단 이 노드 애플리케이션은 다른 사이트에 `HTTP 요청` 을 보낸다. 이 앱과 해당 API의 웹사이트에는 `HTTP 통신` 이 분명히 존재한다.
> 지금은 컨테이너에 노드 앱을 집어넣었는데, 컨테이너 내부에서 외부로 이 요청이 전송될 수 있고, 작동하는지 확인해볼 것이다.

즉, 도커화된 앱에서 가능한 통신 방법으로, HTTP요청을 다른 웹사이트나 웹 API로 전송하는 방법이다.

### 📌 case 2: 컨테이너에서 로컬 호스트 머신으로의 통신

`HTTP` 요청을 웹사이트나 웹 API로 보내는것만이, 도커화된 앱에서 할 수 있는 유일한 통신 방식은 아니다. 호스팅머신, 웹 서비스 또는 데이터베이스와 같은 것을 보유하고 있을 수도 있는데, 도커화된 앱 내부에서 통신하고자 할 수 있다.
즉, 컨테이너 외부의 무언가와 통신하기를 원하는 것이다.

하지만 그 무언가가 웹사이트나 그와 유사한 것이 아니다. 그 대신 호스트 머신에서 실행되는 서비스인 것이다. 예를 들어, 다른 네트워크 컨테이너의 서비스가 아니라 도커 없이도 컴퓨터에서 단순하게 실행되는 데이터베이스 같은것.

자체 데이터베이스에서 데이터를 가져오고 저장하는 코드도 있고, 따라서 데이터베이스에 연결하는 코드 또한 있을것이다. 현재 앱의 `mongoose.connect` 에 해당하는 부분.
이 경우, 대중적인 데이터베이스 엔진인 `MongoDB` 를 사용.

이렇게 호스트머신에서 실행되는 `Mongo` 데이터베이스에 연결하고, 따라서 이것은 이 앱이 컨테이너 내부에서가 아니라 `호스트 머신` 에서 실행되는 데이터베이스와 통신할 수 있어야 한다는 것을 의미한다.

> ✅ 즉, 컨테이너 내부로부터의 통신. 컨테이너화된 애플리케이션 내부로부터의 통신은 호스트 머신에서 실행 중인 특정 서비스에 연결된다고 할 수 있다.
> 컨테이너 또는 컨테이너화된 앱과 그 컨테이너 외부의 무언가 간의 통신. 이 경우 무언가는 호스트 머신, 내 컴퓨터이다.

### 📌 case 3: 컨테이너 간 통신

현재까지 두 종료의 요청에 대해서 보았다.
`컨테이너 => WWW / 컨테이너 => 호스트머신`
도커화된 앱에서 또 다른 형태의 통신이 있다. 이는 컨테이너 내부에서 실행 중인 애플리케이션이 다른 컨테이너와 통신하기 원하는 경우인데,
예를 들어 내부의 `SQL` 데이터베이스가 있는 또 다른 컨테이너가 있다고 가정해보자.
다른 컨테이너의 내부에서 `MongoDB` 데이터베이스나 특정 서비스를 실행중인 컨테이너와 통신하고자한다. 즉, 중간 컨테이너에 있는 애플리케이션이 다른 컨테이너에 있는 SQL 데이터베이스와 통신하기를 원하는 경우이다.

여러 컨테이너 간의 통신도 매우 일반적인 시나리오인데, 다중 컨테이너로 애플리케이션을 구축하는 경우도 일반적이기 때문이다.

지금까지는 쭉, 하나의 컨테이너로만 작업했는데, 조금 더 복잡해진 앱을 사용하게 된다면 다중 컨테이너를 사용하게 된다.
도커 컨테이너를 사용하면 `각각 컨테이너가 한 가지 주요 작업` 만 수행하는 것이 강력히 권장되고, 그것이 모범사례이다. `MongoDB` 데이터베이스를 요구하는 노드 앱의 경우에도,
`app.js` 파일과 모든 요구되는 종속성 및 앱에 속하는 `models` 폴더가 하나의 컨테이너와 하나의 이미지에서 실행되고,
데이터베이스가 다른 이미지를 사용하여 다른 컨테이너에서 실행되는 것이
권장사항이자 모범사례이다.
따라서 다중 컨테이너 앱에 대해 더 많은것을 알아보자.
