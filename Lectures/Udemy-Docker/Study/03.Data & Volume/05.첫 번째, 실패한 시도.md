## Data & Volume

### 05. 첫 번째, 실패한 시도

---

### 📌 실패한 시도

#### 볼륨을 어떻게 컨테이너에 추가할 수 있을까?

볼륨을 추가하는 가장 쉬운 방법 중 하나는 `컨테이너를 만드는데 나중에 사용할 이미지를 만드는 특수한 명령을 Dockerfile에 추가` 하는 것이다.

`VOLUME` 명령을 추가하고, 텍스트 배열을 넣어준다.
이 안에 컨테이너 파일 시스템의 내부의 다양한 경로를 특정할 수 있다. 유지하고자 하는 앱 코드 내부에서 사용된다.

예를 들어, 현재 예쩨에서는 영구 파일을 `feedback` 폴더에 저장하고, `temp` 폴더로 임시로 저장하고있다. 결국 `feeedback` 폴더의 모든 내용은 저장될것이고, `app` 폴더 안에 있다.
그러므로 저장하려는 볼륨은 `/app/feedback` 이다.
✅ 컨테이너 내부의 경로이다.

컨테이너 외부 폴더에 매핑되어질 내 `컨테이너 내부 위치` 이며, 데이터가 생존할 위치이다.
호스팅 머신에서 이제 이 매핑을 수행하는 폴더를 어떻게 제어 할 수 있을까? 일단 제어에 관련해서는 두고, 도커가 볼륨에 넣은 폴더를 제어하도록 놔두고 진행해보자.

`docker build` 로 이미지를 리빌드할것인데, 태그로 `volumes` 를 만들어서 빌드해보자.
`docker build -t feedback-node:volumes .` 로 이미지를 만들고
`docker run -d -p 4000:80 --rm --name feedback-app feedback-node:volumes`
컨테이너를 실행시켜주자

![](https://velog.velcdn.com/images/chromeheartz/post/dedab1c6-48cc-4790-919c-91e2b07091f9/image.png)

폼을 제출해보면 계속 로딩이 되기 시작한다.
`docker logs feedback-app` 으로 확인해보면

```
(node:1) UnhandledPromiseRejectionWarning: Error: EXDEV: cross-device link not permitted, rename '/app/temp/hello.txt' -> '/app/feedback/hello.txt'
(Use `node --trace-warnings ...` to show where the warning was created)
(node:1) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)
(node:1) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
```

`장치간(cross-device) 링크` 가 허용되지 않는것이다.
그래서 파일을 `temp -> feedback` 으로 옮기려고 할때 충돌이 발생한다.
이건 `VOLUME` 과 관련이 있을 것이다.

#### 결국 특정한 볼륨때문에 내부에서 발생하는 문제이다.

도커는 실제로 파일을 컨테이너 파일 시스템 내부의 다른 폴더로 `이동하지 않는다`.
컨테이너 밖으로 이동시킬 뿐이다. 노드에서 `rename` 메소드로 사용해서 문제가 생겼을것이다.
`rename -> copyFile` 메소드로 교체해주고

```node
await fs.copyFile(tempFilePath, finalFilePath);
await fs.unlink(tempFilePath);
```

밑에 `unlink` 를 추가해준다. 이는 본질적으로 파일을 복사하고, 그 후에 수동으로 삭제하는 것이다.
이제 이미지를 다시 빌드하고 컨테이너를 실행해보자.
이렇게 하면 폼을 제출했을때 파일이 잘 보인다. 하지만 컨테이너를 중지했다가 제거하고 다시 시작하게 되면 파일이 없어지게 된다.

동일한 이미지를 기반으로 완전히 새로운 컨테이너를 생성하는데, 파일이 존재하지 않게 된다.
무엇이 문제일까?
