## Data & Volume

### 08. 바인드 마운트 시작하기

---

### 📌 바인드 마운트

`바인드 마운트` 에 대해 알아보자.
이는 우리가 직면할 수 있는 여러 종류의 문제를 해결할 수 있다.
일단 소스 코드에서 무엇이든 변경할 때마다 예를 들어 `server.js / HTML` 등등 그럴때마다 이미지를 다시 빌드하지 않는 한 이러한 변경 사항은 실행 중인 애플리케이션에 반영되지 않는다.

이런일이 일어나는 것은 도커 이미지가 `생성` 될 때 이들 폴더의 `스냅샷` 만 복사한다.
따라서 해당 폴더의 모든 항목에 대한 미래의 변경사항은 이미지에 반영되지 않으므로 `컨테이너` 에도 반영되지 않는것이다.

하지만 개발 중에 도커를 사용한다면 이러한 변경사항이 반영되는것이 매우 중요하다.
그렇지 않으면 변경 사항이 있을때마다 매번 이미지를 전체 리빌드하고, 컨테이너를 다시 시작해야 하기 때문이다.

> 이때 바인드 마운트가 도와준다.

바인드 마운트와 볼륨은 몇 가지 비슷한 점이 있지만, `중요한 차이점` 이 있다.
📍 `도커에 의해 관리되는 볼륨의 위치` 즉, 호스트 머신의 파일 시스템 상의 볼륨이 어디에 있는지 실제로 알지 못하지만, 바인드 마운트의 경우 `위치를 알고 있다` .

호스트 머신상에 매핑될 컨테이너의 경로를 설정하기 때문이다.
그래서 로컬 호스트 머신상의 경로를 완전히 인식할 수 있다.
그렇기 때문에 컨테이너는 볼륨에 쓸 수 있을 뿐만 아니라 읽을 수도 있기에, 소스 코드를 `바인드 마운트` 에 넣을 수 있게 되는 것이다.

> ✅ 그렇게하면 컨테이너는 이를 인식하여 소스 코드를 실제로 스냅샷에서 복사하는 것이 아니라 바인딩 마운트에서 복사한다. 그 폴더는 호스트 머신의 어떤 폴더에 연결되어있고, 컨테이너는 항상 최신 코드에 액세스 할 수 있는 것이다.
> 따라서 `바인드 마운트` 는 `영구적이고 편집 가능한 데이터` 에 적합하다.

명명된 볼륨은 영구 데이터에 도움이 되지만, 편집은 실제로 불가능하다. 어디에 저장되어 있는지 모르기 때문

#### ✅ 바인드 마운트를 어떻게 추가할 수 있을까?

`Dockerfile` 내부에서 할 수 있는 것이 아니다. 실제로 이미지가 아니라 `실행하는 컨테이너` 에만 적용되기 때문에 이미지에 영향을 주지는 않는다.
그러므로 컨테이너를 실행할 때 터미널 내부에서 `바인드 마운트` 를 설정해야 한다.

`docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes` 로 기존에 했던 방식에서 볼륨을 더 추가해보자.
명명된 볼륨 뿐만 아니라 `-v` 를 추가하고, ⭐️ 컨테이너 내부의 매핑하려는 폴더(소스코드를 /app)에 복사하고 있기 때문. 를 적고 그 앞에 콜론을 쓰고, `호스트 머신 상의 경로` 를 앞에 적어준다.
현재를 기준으로 `-v 호스트머신상의경로:/app` 이 될것이다.
현재 `serve.js` 의 path는 `/Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/03-volume/server.js` 이기 때문에 해당 경로를 선택하여 콜론 앞에 추가한다. (파일명 제거)

`docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v "/Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/03-volume:/app" feedback-node:volumes`
최종 명령어.

이 경우에 최소 하나의 파일도 바인딩 할 수 있다. 단일 파일을 컨테이너와 공유하려는 경우 `파일에 파일` 을 바인딩 할 수 있는데, 현재는 폴더를 기점으로 공유해보자.
지금은 전체 폴더를 공유하고자 하기 때문에, 파일명을 제거하는 것이다.

좀더 가독성이 좋게 하기 위해 ""로 묶는 것을 고려해볼 수도 있다.

### 📌 중요한 참고 사항

폴더를 컨테이너에 마운트하는 것에 대한 중요한 참고 사항이 있다.
바인딩 마운트로 공유중인 폴더에 도커가 `액세스` 할 수 있는지 반드시 확인해야한다.
도커의 `preferences` 에 액세스하여 이를 수행할 수 있다.

![](https://velog.velcdn.com/images/chromeheartz/post/636347cb-4cfd-4f20-96a8-1fc2b9785b2d/image.png)

도커 설정의 `file sharing` 에 공유중인 폴더의 상위 폴더가 표시되어야 한다.
지금 공유중인 프로젝트가 사용자 디렉토리의 하위 폴더에 있으니 도커가 액세스 할 수 있다.

컨테이너를 다시 시작시키면 전체 폴더가 컨테이너 내부의 app 폴더에 명명된 볼륨으로 마운트 된다.
그리고 `docker ps` 를 하게 되면 컨테이너가 없다.
종료된 컨테이너는 자동으로 제거되기 때문에, 지금 이건 실행 즉시 종료되는 것처럼 보인다.

일단 `--rm` 을 빼고 다시 확인해보자.
`docker run -d -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "/Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/03-volume:/app" feedback-node:volumes`

그 이후에 `docker ps -a` 를 하면 중지된 컨테이너를 확인할 수 있는데, `docker logs` 를 보면 발생한 오류를 알 수 있다.

![](https://velog.velcdn.com/images/chromeheartz/post/22aba263-14c7-4431-8bae-66e444ea2faa/image.png)

문제는 `Express` 모듈을 찾는데 실패했다는 것을 알 수 있는데, 이는 노드 코드가 실행을 시작하지도 않았다는 것을 알 수 있다.
중요한 종속성이 없기 때문에 실행되지 않는것이다. 근데 `npm install` 으로 모든 종속성을 설치하는데도 왜 없다는 걸까?

> 그건 바인드 마운트로 전체 프로젝트 폴더를 app 폴더에 바인딩하는데 문제가 있다.
