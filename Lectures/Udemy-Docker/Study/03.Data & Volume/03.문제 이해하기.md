## Data & Volume

### 03. 문제 이해하기

---

### 📌 문제

일단 컨테이너를 중지하고, 재시작해보자.
`--rm` 을 추가했기에 새 컨테이너를 사용하려면 docker run을 또 사용해야 한다.
`docker run -p 4000:80 -d --name feedback-app feedback-node`

이번엔 `--rm` 을 작성하지 않고 컨테이너를 실행해보자.
`feedback/hello-world` 를 보려고 하면 파일이 존재하지 않다는 것을 알게 된다. 전에 컨테이너를 올렸을때는 작동했는데 이 컨테이너를 삭제 했기 때문이다.
![](https://velog.velcdn.com/images/chromeheartz/post/ebfa39da-f1d3-4538-9d85-22d67c8791c6/image.png)
`hello-again` 이라는 파일을 만들어보고 컨테이너를 중지해보자.
이후 컨테이너를 제거하지 않고 중지시키고 재시작한다면, 다시 로드할때 파일이 존재하는 것을 알 수 있다.
📍 즉, 파일이 손실되지 않은것이다.

컨테이너를 중지했지만, 제거하지는 않았기 때문이다. 이것에 많은 의미가 있다.

### 📌 격리 개념

이미지를 빌드하는 `Dockerfile` 에 대해 설명할 때 이미지에는 호스팅 시스템 파일 시스템에서 분리된 `자체 내부 파일 시스템` 이 있다고 했다.
그런 다음 그 이미지를 기반으로 도커 컨테이너를 시작하면 그 이미지 위에 얇은 `read-write` 레이어로 컨테이너가 추가된다. 따라서 기본적으로 이미지 파일 시스템에 액세스할 수 있으며 이미지를 조작하지 않고도 읽고 쓸 수 있다. 하지만 `그곳에서만` 읽고 쓸 수 있다.

매우 효율적인 방식으로 관리되는 자체 복사본을 가지는데, 거기에서 읽고 쓸 수 있다는 것이 중요하다.
문제는 파일 시스템이 `컨테이너 내부` 에 있다는 것이다. 따라서 컨테이너를 중지하고 다시 시작해도 모든것이 정상이다. 컨테이너를 `제거` 한다면 얘기가 달라진다.

그렇게 하면 컨테이너의 모든 데이터가 지워진다.
새 컨테이너를 실행해도, 동일한 이미지 상의 공간에 있다고 해도, 이전 컨테이너에서 생성되어 저장된

> ✅ 모든 데이터는 손실된다. 이미지는 `읽기 전용` 이기 때문.
> 따라서 컨테이너는 파일을 생성할 때 파일을 이미지에 쓰지 않는다(이미지에 저장하지 않는다는 뜻). 상단에 추가되는 자체 `read-write` 레이어에 저장한다.

그래서 컨테이너가 제거되면 변경되지 않는 이미지만 남게 되는것이다.

즉, 새 컨테이너를 시작하면, 동일한 이미지 상에서 실행되어진 이전 컨테이너에 의해 변경된 것이 없는 `동일한 기본 파일 시스템` 으로 시작한다. 동일한 이미지에 기반한 다수의 컨테이너가 서로에게 `완전히 격리` 되는것이 도커의 핵심 아이디어이다.

#### 그럼 컨테이너를 제거하면 데이터가 손실되는데 해결책은 무엇일까?
