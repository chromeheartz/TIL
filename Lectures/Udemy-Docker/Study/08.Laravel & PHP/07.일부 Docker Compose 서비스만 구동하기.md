## Laravel & PHP

### 07. 일부 Docker Compose 서비스만 구동하기

---

### 📌 일부 Docker Compose

이제 애플리케이션 실행 가능 여부를 확인하기 위해 `src` 폴더 내부, 즉 새로 생성된 `Laravel` 애플리케이션 내부에 있는 `.env` 파일을 먼저 봐보자.
이것은 `Laravel` 에 의해 생성되었으며 해당 앱에 대한 구성을 가지고 있다. 즉, `Docker` 설정이 아니라 `Laravel` 설정을 위한 것이다.

![](https://velog.velcdn.com/images/chromeheartz/post/faa5f15f-c776-4bee-bc8e-c61811c9c8e7/image.png)

여기서 중요한 것은 `DB_CONNEXTION` 부분인데 MySQL 데이터베이스에 연결하는데 사용할 연결 정보를 담고 있는 블록이다.Laravel이 데이터베이스에 연결할 수 있도록 이를 조정해야 한다.

먼저 사용하려는 데이터베이스를 조정해야하는데 `MySQL` 서버를 시작하기 위해 `mysql.env` 에서 설정한 값으로 작업해야 한다.
⭐️ 중요한 것은 여기의 `DB_HOST` 는 `IP 주소` 가 아니라 `MySQL 서비스의 이름` 이라는 것이다. 즉, 현재 경우에는 mysql이 될것이다.
이 요청은 PHP Laravel 애플리케이션 내부에서 전송되므로 그 내부에서 컨테이너로 전송된다. 따라서 도커는 컨테이너 이름을 IP주소로 변환할 수 있는 것이다. 이들 애플리케이션 서버는 동일한 네트워크에서 실행되기 때문.

```env
DB_CONNECTION=sqlite
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=homestead
DB_USERNAME=homestead
DB_PASSWORD=secret
```

이렇게 조정을 한 다음에는 `.env` 파일을 저장하고 `docker-compose up` 으로 시작하려는 서비스를 불러와보자. 하지만 이것을 사용하기 전에 어떤 서비스가 사용될지 평가해보자.

#### 서비스

일단 서비스로는 `server / php / mysql` 이 있다.
`server` 는 메인 엔트리포인트이며 애플리케이션을 제공한다. 그리고 요청을 PHP 인터프리터에 포워딩한다. 그러면 PHP 인터프리터는 결국 간접적으로 MySQL 데이터베이스와 대화를 한다. 코드에서 데이터베이스에 연결하기 때문.

여기서 문제가 발생하는데 메인 엔트리포인트인 `server` 는 현재 소스 코드에 대해 아무것도 모른다. PHP 인터프리터는 소스 코드에 대해 알지만 그것만으로는 충분하지 않다.
들어오는 요청이 먼저 server에 도달하고 PHP 파일에 대한 요청만이 PHP 인터프리터에 전달된다.
**📍 이는 이러한 PHP파일이 server에 노출되어야 함을 의미한다**
그렇기 때문에 부가적인 볼륨을 추가해야 한다.
이 볼륨은 `바인딩 마운트` 가 되는데 `src` 폴더를 컨테이너 내부의 `/var/www/html` 폴더에 바인딩 한다.

> `nginx.conf` 파일을 보면 `/var/www/html` 폴더에서 콘텐츠를 제공하고 파일을 찾기 때문이다. 정확히는 public폴더에서 찾지만 그 또한 src폴더 내에 존재한다.
> 따라서 이 경로로 바인딩 하는 것은 `server` 를 통해 컨텐츠를 사용하기 위해 해야만 하는 일인 것이다.

이제 서비스 시작을 살펴보자.
서비스를 실행하고 애플리케이션 컨테이너를 실행하기 위해 `docker-compose up` 을 사용해보자. 항상 이렇게 사용했는데 모든 서비스를 구동하고 싶지 않으니 `server, php, mysql` 서비스만 할것이다.

#### target

`docker-compose --help` 를 입력해서 문서를 보면 특별한 기능이 있다.
`특정 서비스` . 즉, 구동해야 하는 하나 이상의 서비스를 대상으로 할 수 있다.
디폴트로 `docker-compose up` 을 실행하면 `yaml` 파일에 지정된 모든 서비스가 구동되지만 `target` 으로 지정해서 사용할 수 있다.

`docker-compose up -d server php mysql`

이렇게하면 `nginx` 컨테이너가 뭔가 작동하지 않아서 실행이 안된것을 볼 수 있다.
그리고 ARM 맥(M1/M2/M3) 문제 때문에 `mysql:8.0` 으로 버전을 올려주었다.

대신 종료된 컨테이너에서 찾을 수 있다. 뭔가 작동하지 않은것이다.
`config` 파일이 틀린 경로에 바인딩 되어 있었다. `nginx.conf` 파일을 `nginx.conf:ro` 여기에 마인딩하는것이 아니라 `/etc/nginx/conf.default.conf/:ro` 로 바인딩 해주어야 한다.

결국 nginx이미지 내부에 설정된 더 큰 nginx 구성으로 병합되는 특수 파일이라 할 수 있다. 따라서 이 바인드 마운트를 사용하여 자체 파일을 그 파일에 병합해야 한다.
`docker-compose down` 으로 모든 것을 중단시키고 다시 시작해보자.
![](https://velog.velcdn.com/images/chromeheartz/post/49c2ccbc-1098-4649-8a55-46b9e376a0a1/image.png)

이후 `localhost:8000` 을 방문하여 페이지를 보게 되면 Laravel 앱이 표시되는 것을 볼 수 있다.

#### depends_on

모든 서비스의 이름을 각각 지정하여 시작하는것은 꽤 성가신 일이다.
예를 들어 `server` 서비스의 이름만 지정하여 다른 두 서비스가 자동으로 시작되게 하고싶다. 이제 `server` 에 종속성을 추가하여 작동하도록 할 수 있다.
`depends_on` 으로 `php / mysql` 을 입력하여 서버 서비스가 의존하는 서비스로 지정한다.

여기에는 많은 의미가 있다.
`nginx` 서버는 다음의 경우에만 작동한다. `php 서비스와 통신할 수 있고 mysql 서비스와 통신할 수 있는 경우` 에만 작동한다.
즉 두 서비스에 의존하는 것이다.

`depends_on` 구성이 추가되면 `docker-compose` 가 이 `server` 서비스를 불러올 대 의존하는 서비스도 자동으로 불러온다.
`docker-compose up -d server` 로 키게되면 모든 것을 다 키는 것을 볼 수 있다.

여기서 `up` 명령을 좀 더 조정하려고 한다.
추가할 수 있는 부가 옵션이 있는데 `php` 와 같은 커스텀 이미지와 관련이 있다.
현재 `docker-compose` 가 디폴트로 수행하는 작업은 이미지가 있는지 확인하고 그 이미지를 사용하는 것이다.
**⭐️ 즉, 결코 이미지를 리빌드 하지 않는다**

Dockerfile이 변경되거나 하면 `docker-compose` 에 의해 적용되지 않을 것이다.
`docker-compose` 없이 변경된 이미지를 리빌드하려면 기존에는 수동으로 `docker build` 를 실행해야 했다. `docker-compose` 가 `Dockerfile` 을 재평가하여 필요한 경우에 이미지를 리빌드하도록 하려면 `--build` 옵션도 추가할 수 있다.
`docker-compose up -d --build server`

이미지의 레이어 개념으로 인해 레이어가 캐시되기 때문에 변경된 것이 없다면 리빌드 되지 않는다. `Dockerfile` 을 변경했거나 `Dockerfile` 을 통해 이미지에 복사되는 폴더 또는 파일을 변경했다면 `--build` 를 추가해서 할 수 있다는 뜻이다.

> php.dockerfile의 php 버전을
> `FROM php:8.2-fpm` 으로 바꾸었고,
> `server` 의 `volumes` 의 수정했던 부분을
> `- ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro` 경로를 이렇게 맞춰주었다.
> 또한 laravel의 .env의 DB_CONNECTION또한 mysql로 잘 넣어주었다.

하지만 항상 이를 보장하기 위해 `--build` 를 고정으로 사용해도 된다.
`views/welcome.blade.php`
