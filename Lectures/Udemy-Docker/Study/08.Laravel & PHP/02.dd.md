## Laravel & PHP

### 02. Nginx Container

---

![](https://velog.velcdn.com/images/chromeheartz/post/c176729d-1434-45e2-96fe-23b539634810/image.png)

### 📌 Nginx(Web Server) Container

`composer` 를 실행하려고하면 그 명령을 찾을 수 없다고 나온다.
`Laravel` 앱을 빌드하는데 필요한 도구들이 없는 상태이기 때문에 도커를 사용해서 만들어보자. 일단 `docker-compose.yaml` 파일을 추가해서 다중 컨테이너를 구축하고 컨테이너끼리 상호작용을 시킬것이다.

도커 컴포즈로 `애플리케이션 컨테이너 / 유틸리티 컨테이너` 를 모두 보유하도록 하자.
`services` 를 지정하는데 `6가지 서비스` 가 필요할것이다
.
일단 `server` 서비스를 만들어서 `nginx` 서버를 만들자.
이 서버는 들어오는 모든 요청을 받아들여 PHP 인터프리터를 트리거한다.
그러므로 php 컨테이너를 가지게 되고, 이는 PHP / Laravel 코드를 실행한다.
MySQL 데이터베이스를 보유하는 mysql 컨테이너도 있고, 이후에 유틸리티 컨테이너를 가질것인데 `composer / npm / artisan` 이 3개를 만들것이다.

일단 server는 nginx를 사용할것인데 공식 이미지가 있다. 즉, mongodb / node처럼 `Nginx` 에 대한 공식 이미지를사용해서 서버를 설정할것이다.

`server` 라는 이름을 넣고 `image: nginx` 를 보게되면 다중 태그를 가진다.
이미지의 여러 버전이 있는데 `stable-alpine` 태그를 사용할것이다. 매우 슬림한 Linux운영체제를 기반으로하는 이미지 버전이다.

따옴표 사이에 텍스트를 넣는것이 필수는 아니지만 묶는것이 조금 더 안전하다. 잘못된 방식으로 해석되지 않도록 해줄 수 있다.

웹서버도 포트를 노출해야 하는데, 어떻게 알 수 있을까?
`nginx` 이미지의 공식 문서를 보면 `80` 을 내부적으로 노출할 수 있다고 써있다. 이 포트를 호스트 머신의 특정 포트에 바인딩하고자 하니 `8000:80` 으로 포트 8000을 이미지에 의해 노출되는 포트인 80에 바인딩을 하자. (실행 중인 컨테이너에 의해 노출되는 포트가 80이라는뜻)

현재 기점에서 서버는 그다지 유용하지 않다. 무엇을 해야 하는지 모르기 때문이다.
애플리케이션에서 해야 할 일은 들어오는 요청을 보고 `PHP Container` 로 전달하는 것이다. 이 컨테이너는 나중에 만들 것인데, 그 컨테이너에서 PHP 코드를 실행하게 된다.
따라서 자체 구성을 제공하게 하기 위해 `volumes` 로 바인드 마운트를 추가하고 로컬 폴더에 파인딩한다.
`./nginx/nginx.conf:/etc/nginx/nginx.conf:ro`

`nginx` 폴더에 `nginx.conf` 파일이 있다고 가정해보자.
전체 폴더를 바인딩하지 않기 위해 개별 파일을 대상으로 지정할 수 있는데, 특정한 하나의 파일을 컨테이너에 복사하고자 한다면 그 특정 파일을 대상으로 지정할 수 있다.
컨테이너의 절대 경로에 바인딩 해보자. `/etc/nginx/nginx.conf` 이런식으로 경로를 구체적으로 한 이유가 궁금할 수 있는데, 이미지에 대한 공식 문서에 이렇게 작업해야 한다고 나와있기 때문이다.

어떤 포트가 노출되어야 하는지 이미지에서 어떤 폴더가 작업을 수행하는지 모르기에 그런 것들을 알기 위해서는 문서를 읽어보아야 한다.
![](https://velog.velcdn.com/images/chromeheartz/post/555a8805-c082-4618-9d9f-166e3d5a3f94/image.png)

여기를 보면 컨테이너 내부경로에 바인딩을 해서 자체 구성을 전달할 수 있다는 것을 알 수 있다. 또한 `읽기 전용` 으로 설정해야 한다. 컨테이너가 구성을 변경해서는 안되기 때문.

이를 통해 웹서버에 대한 자체 구성파일을 웹서버 컨테이너에 전달할 수 있다.
`conf` 파일은 하단 참조

```conf
// nginx.conf
server {
    listen 80;
    index index.php index.html;
    server_name localhost;
    root /var/www/html/public;
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php:3000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}
```

기본적으로 포트 80에서 수신 대기하는 구성이다. 따라서 컨테이너 내부의 다른 포트에서 수신 대기하고싶으면 포트를 변경해야 한다. 이후 `index` 파일에 대한 요청을 처리하고 들어오는 요청에 응답하는데 사용할 수 있는 파일을 디렉토리에서 찾는다.
`/var/www/html/public` 이 디렉토리는 컨테이너에도 없고 로컬에도 없다. 하지만 곧 보게 될것이다.

이후에 모든 수신 요청을 기본적으로 `index.php` 파일로 리디렉션하거나 PHP파일을 대상으로 하는 요청이 인터프리터로 전달되도록 하는 리디렉션 규칙이 있다.
물론 지금은 동작하지 않는다.

```yaml
version: "3.8"

services:
  server:
    image: "nginx:stable-alpine"
    ports:
      - "8000:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  # php:
  # mysql:
  # composer:
  # artisan:
  # npm:
```
