## Laravel & PHP

### 05. Composer Utility Container

---

### 📌 Composer 유틸리티 컨테이너

이제 유틸리티 컨테이너가 될 `composer` 를 작성해보자.
이 컨테이너는 `Laravel` 에 의해 내부적으로 사용된다. 그 뿐만 아니라 가장 중요한 것은 처음에 `Laravel` 애플리케이션을 설정하는데 사용할 수 있다는 것이다.

이를 위해 커스텀 Dockerfile을 추가하자. 몇 가지 미세 조정을 한 베이스 이미지가 필요하다. `composer.dockerfile` 을 추가.
베이스 이미지로 `composer` 을 넣어준다. 이 이미지에서 시작하여 `latest` 태그를 사용해서 최신 이미지 버전을 사용한다.
커스텀 `Dockerfile` 을 사용하는 이유는 `ENTRYPOINT` 를 지정하기 위해서이다.
docker-compose에서도 이 방법을 수행할 수 있지만 이후에 확인해보자. `dockerfile` 이 명확하며 이해하기 쉽기 때문.

`ENTRYPOINT` 에 `composer` 실행파일을 넣어준다. 그 실행파일은 `composer` 이미지 / 컨테이너 내부에 존재한다. `로컬 호스트 머신` 에 존재하는게 아님.
그리고 `composer` 에 의해 실행되는 모든 명령에 추가되어야 하는 플래그를 추가하는데 `--ignore-platform-reqs` 명령이다.

이렇게 하면 일부 종속성이 누락되더라도 경고나 오류 없이 실행할 수 있다.
올바른 작업 디렉토리를 설정하는 것 또한 중요한데 이를 `/var/www/html` 로 설정한다.

```dockerfile
FROM composer:lastest

WORKDIR /var/www/html

ENTRYPOINT ["composer", "--ignore-platform-reqs"]
```

이렇게 저장하고 `docker-compose` 파일로 돌아간다.
`composer` 서비스에 `build` 를 추가하고 `context` 를 `./dockerfiles` 로 설정한다. 그리고 옵션을 `composer.dockerfile` 로 설정해준다.

build를 설정하고 나면 `Laravel` 을 설치하고 프로젝트를 설정하는데 소스 폴더에서 수행하게 된다. 즉, 내부적으로 `/var/www/html` 폴더에서 작업이 수행되는 것이다.
따라서 `volumes` 또한 추가하여 소스 폴더를 컨테이너 내부의 폴더에 바인딩한다.

예를 들어, composer를 사용하여 컨테이너 내부의 폴더에서 Laravel 애플리케이션을 생성한다면 로컬 호스트 머신의 소스 폴더로 다시 미러링된다.

```yaml
composer:
  build:
    context: ./dockerfiles
    dockerfiles: composer.dockerfile
  volumes:
    - ./src:/var/www/html
```
