## Laravel & PHP

### 03. PHP Container

---

### 📌 PHP Conatiner

`php container` 를 만들어보자.
커스텀 Dockerfile을 사용할것이다. 필요한 모든 것을 완성된 이미지가 없기 때문.
공식 이미지를 사용해서 그 이미지를 기반으로 만들것이다.

php만 사용하려는 것이 아닌 Laravel이 필요로하는 몇몇 확장프로그램도 설치하려고 한다. nginx 폴더랑 같은 레벨로 `dockerfiles` 폴더를 만들어서 `php.dockerfile` 을 정의해주자.

`7.4-fpm-alpine` 이미지를 사용할것이다.  
그리고 `RUN` 을 실행할것인데, 필요한 부가 종속성을 설치할 명령을 실행할것이다.
`docker-php-ext-install / pdo / pdo_mysql` 이다.
이 명령들이 적절한 폴더에서 실행되도록 작업 디렉토리를 `/var/www/html` 로 설정한다. 작업 디렉토리가 좀 이상하게 보일 수 있지만 웹사이트를 제공하는 웹 서버의 표준적인 폴더이다.

따라서 실제로 모듈 전체에 걸쳐 구축할 모든 컨테이너에서 최종 앱을 보관해야하는 폴더로 이 폴더를 사용할 것이다. `nginx.conf` 의 `root` 에서 본 적 있는데, 이 폴더에서 웹 애플리케이션 파일을 찾을 수 있다고 가정했다. 정확히는 그 폴더의 하위 폴더에서.
그리고 전체 모듈에서 이 폴더를 고수해야 하는것이 결국 `Laravel PHP` 앱을 보관해야 하는 컨테이너 내부의 폴더이기 때문이다.
그래서 이 폴더를 작업디렉토리로 전환하여 부가 종속성을 설치하는 것이다.

```dockerfile
# php.dockerfile
FROM php:7.4-fpm-alpine

WORKDIR /var/www/html

RUN docker-php-ext-install pdo pdo_mysql
```

여기서 `CMD / ENTRYPOINT` 가 없는 것을 알 수 있는데, 만약 도커파일에 이 두 명령이 없다면 `베이스 이미지` 의 `CMD / ENTRYPOINT` 를 사용하게 된다.
그리고 베이스 이미지인 `php 베이스 이미지` 에는 디폴트 명령이 있다.
이 명령은 PHP 인터프리터를 호출하는 명령이다. 즉, 이 이미지는 베이스 이미지의 명령령을 자동으로 실행하고 해석되어야 하는 PHP 파일이 들어오면 이들이 처리된다.

이후 `docker-compose` 에서 Dockerfile을 참조시킬 수 있다. `build` 를 추가하고 빌드 구성을 설정.
하지만 `dockerfiles` 폴더를 가리키는 것만으로는 충분하지 않다. 이 폴더 안의 파일의 이름이 `Dockerfile` 이라고 되어있지 않기 때문에 세부적인 구성이 필요하다.
`context` 로 파일을 찾을 수 있는 폴더를 특정하고 `dockerfile` 로 파일명을 지정한다.

이렇게 하면 도커 컴포즈는 파일을 찾아 관련된 이미지를 빌드할 수 있다.

#### 이후 해야할 작업

일단 `PHP 인터프리터` 가 소스코드에 접근할 수 있도록 해주어야 한다. 지금은 소스코드를 가지고 있지 않지만 나중에 `PHP Laravel` 앱 코드를 가지게 될것이다. 그리고 결국 그 소스코드는 컨테이너의 내부 폴더에서 사용 가능해야 하기 때문에 `바인드 마운트` 가 필요하다.
프로젝트 폴더에서 소스코드를 작업하고자 하기 때문이다.

일단 로컬 호스트 머신의 프로젝트 폴더에 `src` 라는 폴더를 만들어주고 `php` 에 `volumes` 를 추가해서 볼륨 하나를 지정해보자.
`- ./src:/var/www/html:delegated` 이렇게 `delegated` 를 추가하여 성능을 약간 향상 시킬 수 있다.

> `delegated` 는 결국 컨테이너가 일부 데이터를 기록해야 하는 경우에 그에 대한 결과를 호스트 머신에 즉시 반영하지 않고 그 대신 `batch` 로 기본 처리함으로써 성능이 약간 나아지는 최적화 옵션이다.

반드시 할필요는 없지만 일단 추가해서 사용해보자.
이 컨테이너는 폴더에 자주 기록하지 않아야 하기 때문에 또는 올바르게 기록을 하더라도 호스트 머신에 그 결과가 즉시 반영될 필요가 없다.
호스트 머신 상에서 즉시 액세스해야 하는 항목을 기록하지는 않기 때문.
특정 데이터를 하드 디크스에 쓰기 때문에 `읽기 전용 옵션` 은 사용하지 않는다.

`Laravel` 은 실행 될 때 특정 파일을 생성한다.
예를 들어, 응답의 일부로 되돌려지는 `view` 같은 것들. 이것이 볼륨을 추가하는 중요한 이유 중 하나이다. 볼륨은 소스 코드를 위한 폴더를 가지게 하고, 소스 코드 작업을 할 수 있게 하며 `PHP 인터프리터` 에 노출할 수 있게 한다.

또 중요한 것은 `PHP 인터프리터` 가 작업용으로 수신하는 포트에 대한 것이라 할 수 있다.
포트는 `nginx.conf` 에 정의되어 있다. 포트 3000으로 보내고 있고 IP주소(php:3000의 php부분)를 가질 수 있는데, 현재는 `docker-compose` 파일에서 생성되는 모든 컨테이너는 동일한 네트워크의 일부이며 이름으로 서로를 찾을 수 있기 때문에 `php` 라고 설정해주었다.

`공식 php 이미지` 의 dockerfile을 살펴보면 이미지가 실제로 내부적으로 `9000` 포트를 노출한다는 것을 알 수 있다. 즉, 9000 포트가 컨테이너에 의해 노출된다는 것이다.
`nginx.conf` 에서는 `3000` 을 예상했지만, 이제 9000으로 매핑을 해야 한다.

`ports` 를 설정해줄것인데 `호스트머신포트:컨테이너내부포트` 를 설정해주면 된다.

#### 포트가 진짜 필요할까?

결국 이 `php container` 와 통신하려는 것은 `nginx server` 라는 것을 기억해야 한다. `php:3000` 처럼 이름으로 참조하는 이유가 그것이다.
이 경우에 포트는 컨테이너에 바로 연결되는데, 이것은 로컬 호스트 머신에서 전송하는 경우가 아니다. 따라서 매핑은 아무런 작업도 수행하지 않는다.
호스트 머신에서 php컨테이너와 상호작용하려는 경우에는 `ports` 를 사용해서 매핑을 해야 한다.

하지만 `server container` 에서 요청을 전송하기 위해 할 필요는 없다. 대신 `nginx.conf` 파일의 포트를 `php:9000` 으로 변경해야 한다.
로컬호스트를 통해서 통신하는 것이 아닌 `컨테이너간 직접 통신` 을 하고 있기 때문이다.

```yaml
version: "3.8"

services:
  server:
    image: "nginx:stable-alpine"
    ports:
      - "8000:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  php:
    build:
      context: ./dockerfiles
      dockerfile: php.dockerfile
    volumes:
      - ./src:/var/www/html:delegated
    # ports:
    #   - "3000:9000"
  # mysql:
  # composer:
  # artisan:
  # npm:
```

지금은 `nginx.conf` 의 `fastcgi_pass php:9000` 으로 포트를 바꾸어주었기 떄문에 yaml에서 ports를 사용하지 않고 진행할 수 있다.
