## Docker Compose

### 02. Compose file

---

### 📌 Compose 파일 만들기

전에 했던 것처럼 `backend / frontend` 가 있는 프로젝트를 예씨로 들어보자.
도커 컴포즈는 왜 Dockerfile을 대체하지 않기 때문에 `Dockerfile` 이 필요하다.

#### 도커 컴포즈로 어떻게 시작할 수 있을까?

프로젝트 폴더에 `docker-compose.yml / yaml` 파일을 만든다.
확장자는 `yml / yaml` 이 될 수 있는데, `yaml` 은 들여쓰기를 사용하여 구성 옵션간의 종속성을 표현하는 특정한 텍스트 포맷일 뿐이다.

파일을 만들어서 `다중 컨테이너 환경 / 프로젝트 설정` 을 기재한다.
항상 `version` 을 정의하는 것으로 시작한다. 여기서 버전이란 앱이나 파일의 버전을 의미하는 것이 아니라 `도커 컴포즈 사양의 버전` 을 지정한다.
따라서 여기서 정의한 버전이 컴포즈 파일에서 사용할 수 있는 기능에 영향을 미친다.

`docs.docker.com/compose/compose-file` 문서를 확인해보면 컴포즈 파일에서 설정할 수 있는 모든 구성 옵션에 대한 레퍼런스들을 찾을 수 있고, 사용 가능한 컴포즈 사양 버전도 찾을 수 있다.또한 파일에 추가할 수 있는 방대한 구성 옵션들도 있다.

현재 `3.8` 을 지정해서 해보자.
이후에는 `services` 이다. 이것은 버전과 같은 형태의 값을 가지지는 않고, 대신 몇몇 `중첩 된 값` 을 넣어준다.
`services` 에서는 들여쓰기를 해서 넣어주는 것이 중요한데, `yaml` 은 들여쓰기를 사용하여 종속성을 표현하기 때문이다.
여기 하위요소들이 필요하다. 현재 3개의 컨테이너가 있으므로 `3개의 하위요소` 를 가질것인데, 컨테이너에 `label` 을 지정하기 위해 원하는 이름을 골라서 컨테이너에 이름을 지정할 수 있다.

모두 같은 들여쓰기 수준에 있어야한다.

```
services:
  mongodb:
  backend:
  frontend:
```

이렇게 프로젝트가 3개의 컨테이너를 사용할 것이란것을 정의할것이다.

### 📌 Compose file 구성(configuration)

이제 개별 서비스와 컨테이너를 구성해보자.
일단 `mongodb` 부터. 기존에 공식 이미지를 사용했었다

```
docker run --name mongodb \
  -e MONGO_INITDB_ROOT_USERNAME=max \
  -e MONGO_INITDB_ROOT_PASSWORD=secret \
  -v data:/data/db \
  --rm \
  -d \
  --network goals-net \
  mongo:8.2.1
```

이걸 어떻게 `docker-compose.yaml` 파일로 변환할까?
`image` 키를 사용하는데 컨테이너 아래에 기입한다. 들여쓰기를 해주고, `mongo:8.2.1` 이라는 이름을 지정해준다. 지금은 버전문제때문에 명시해놓았지만 그냥 `mongo` 라고 해도 된다.
이렇게 알려주게 되면 `mongodb` 컨테이너가 이 이미지를 기반으로 해야 한다는 것을 알 수 있다. 로컬이나 더크 허브 리포지토리에서 조회되는 이미지 이름인데, `academind/hello-world` 와 같은 자체 저장소일 수도 있다.

> ⭐️ 기존에 `detached` 모드에서 실행하고 종료될 때, 자동 제거하고싶었는데 이게 `docker-compose` 에서는 디폴트이다.
> 서비스를 중단하면 서비스가 제거되고, `detached` 모드를 사용하는 것으로 간주된다.

볼륨은 `volumes` 키를 추가할 수 있는데, `image` 같은 레벨로 추가해줄 수 있다.
`volumes` 아래에 더 많은 중첩 값을 가질 수 있다. 하나 이상의 볼륨이 있을 수 있기 때문
`-` 를 추가해서 볼륨을 넣어준다. 볼륨 이름, 콜론, 컨테이너 내부 경로 순서로 적어주면 되고 `ro(읽기 전용)` 과 같은 부가 옵션도 추가할 수 있다.

이후 환경 변수는 `environment` 로 써주면 되고, 환경 변수를 특정하기 위한 두 가지의 대체 구문이 있다.

- `MONGO_INITDB_ROOT_USERNAME: root` 이런식으로 써주어도 되고,
- `-` 를 추가하여 환경 변수를 사이에 `=` 기호를 가진 `키-값` 쌍으로도 할 수 있다.

> ✅ `docker run` 으로도 할 수있는 `환경변수 파일` 을 지정할 수 있다.
> docker run에서 `--env-file` 옵션을 추가한다음 파일을 지정할 수 있다.
> 예를 들어 `/env/mongo.env` 파일이 있다고 가정하면 compose에서는 `docker-compose.yaml` 파일에서 사용하려는 환경 변수 파일에 대한 상대 경로를 입력한다
> `env_file`을 넣고 `- ./env/mongo.env` 형식으로 넣어주면 된다.

> ⭐️ `yaml` 을 사용할때 옵션을 지정하는데 `:` 을 가지고 있다면 `yaml` 객체를 생성하기 때문에 -가 필요없고, : 가 없는 단일 값의 경우에는 -가 필요하다.

마지막으로 네트워크를 추가해보자
컨테이너가 속해야 하는 모든 네트워크를 특정할 수 있는데, 많은 경우에 이 작업을 하지 않아도 된다. `📍 도커 컴포즈를 사용하면 도커가 이 컴포즈 파일에 특정된 모든 서비스에 대해 새 환경을 자동으로 생성하고, 모든 서비스를 즉시 그 네트워크에 추가하기 때문`
따라서 하나의 동일한 컴포즈 파일에 정의된 이러한 모든 서비스는 이미 도커에 의해 생성된 동일한 네트워크의 일부가 된다.
따라서 네트워크를 지정하지 않아도 된다.

물론 특정하는 것도 가능한데 `networks` 키를 추가하여 `- goals-net` 같은 형식으ㅗ 추가해줄 수도 있다.

#### 최상위 수준에서의 volumes

`servies` 아래에 들여쓰기 한 수준이 아닌 동등한 들여쓰기 수준으로 `volumes` 키가 있어야 하는데, `servies` 에서 사용중인 명명된 볼륨이 나열되어야 한다.
현재는 `data` 인데, 그 다음에는 값이 없다.
이상하게 보일 수 있지만 이것은 `servies` 를 위해 생성해야 하는 `명명된 볼륨` 을 인식하기 위한 이름이다.

추가 참고 사항으로, 다른 서비스에서 동일한 볼륨이름으로 사용하면 그 볼륨이 공유된다. 따라서 다른 컨테이너가 호스트 머신상의 동일한 볼륨 동일한 폴더를 사용할 수 있다.
하지만 익명 볼륨과 바인드 마운트는 지정할 필요가 없다.

```yaml
// docker-compose.yaml
version: "3.8"
services:
  mongodb:
    image: "mongo:8.2.1"
    volumes:
      - data:/data/db
    # environment:
    #   MONGO_INITDB_ROOT_USERNAME: root
    #   MONGO_INITDB_ROOT_PASSWORD: secret
    #  - MONGO_INITDB_ROOT_USERNAME=root
    env_file:
      - "./env/mongo.env"
    network:
      - goals-net
  # backend:
  # frontend:
volumes:
	data:
```
