## Utility Container

### 05. ENTRYPOINT 활용

---

### 📌 ENTRYPOINT

이제 유틸리티 컨테이너를 생성하면 모든 명령을 실행할 수 있다.
즉, `npm 명령` 을 실행할 수 있는 유틸리티 이미지로 유틸리티 컨테이너를 올린것이다.

`docker run -it -v /Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/07-utility-container:/app node-util npm install`

컨테이너의 내부에서 설치하기 위해 `npm install` 을 실행해보자.
즉, 이것으로 보호하기 위해 모든 것을 할 수 없도록 더 제한된 유틸리티 컨테이너를 갖게 된다.
컨테이너에서 실수로 모든 것을 삭제하는 명령을 실행하여 바인드 마운트로 인해 호스트 머신에서도 콘텐츠를 삭제하는 것을 방지할 수 있다. (다른 명령은 안되지만 `npm` 명령은 되는것)

이렇게 실행할 수 있는 명령을 제한하는 것도 꽤 좋은 방법이 될 수 있다.

이제 `Dockerfile` 에 이를 위한 부가 명령이 있다
`ENTRYPOINT` 인데, `CMD` 와 형식은 비슷하지만 중요한 차이점이 있다.

```dockerfile
CMD ["npm"]
```

`docker run` 에서 이미지 이름 뒤에 명령을 추가하면 이 명령이 실행된다.
즉, `npm` 을 지정해놓으면 이미지를 리빌드 할 때 이미지 이름 뒤에 `npm` 명령을 추가할 수 있다.

`docker build -t mynpm .` 으로 이미지를 빌드해보자.
그리고 `run` 으로 시작하는데, `package.json` 을 삭제하고 진행해보자.

`docker run -it -v /Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/07-utility-container:/app mynpm init`

이렇게 `ENTRYPOINT` 를 작성해놓았기 때문에 `init` 만 실행하면 된다.
이렇게 하면 프로젝트가 설정이 된다 `install` 을 넣어서 다시 한번 실행해보자.
그럼 `package-lock.json` 이 생기는것이 보이고 모든 종속성이 설치가 된다.

⭐️ 하지만 명령이 완료되면 항상 컨테이너가 종료되는 점을 명심하자.

로컬 폴더가 바인드 마운트이기 때문에 `package.json` 파일을 `/app` 폴더에 복사했고, 따라서 `/app` 폴더에서 실행되는 `npm install` 은 `package.json` 파일을 선태갛여 컨테이너 내부에서 사용할 수 있었던 것이다.
`package-lock.json` 은 삭제를 하자.

여기서 만약 종속성을 추가하려고 하는경우에는 (예를 들어 `express` 를 추가한다고 해보자)

`docker run -it -v /Users/bibi/Documents/GitHub/TIL/Lectures/Udemy-Docker/Code/07-utility-container:/app mynpm install express --save`

`--save` 로 명시적 종속성을 설치할 수 있다.
이렇게 하면 `node_modules` 파일들이 생성되는것을 볼 수 있다. 바인딩 마운트로 인해 로컬 폴더로 미러링 되는 것이다.

하지만 접근 방식에는 단점이 있다. 터미널의 명령 프롬프트에서 `꽤 긴 명령` 을 실행해야 하는데, 이것에 대한 해결책은 `docker-compose` 에 있다.

> ✅ `docker run` 을 실행할때 마지막에 실행할 명령을 직접 지정할 수 있는데, `docker run node ls / docker run node rm - rf /` 등을 하는데 그럼 모든 명령어를 자유롭게 실행할 수 있다. 하지만 dockerfile에 `ENTRYPOINT` 가 있다면 컨테이너는 항상 해당 명령을 실행하는 상태로 시작된다. 즉, 컨테이너를 실행할 때 추가로 실행되는 명령은 모두 `npm` 뒤에 붙게 된다.
