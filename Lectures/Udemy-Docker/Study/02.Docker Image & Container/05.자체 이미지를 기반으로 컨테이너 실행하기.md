## Docker Image & Container

### 05. 자체 이미지를 기반으로 컨테이너 실행하기

---

### 📌 자체 이미지를 기반으로 컨테이너 실행하기

Dockerfile을 만들었는데 이것을 이미지로 변환한 다음 궁극적으로 컨테이너로 변환하는 방법은 무엇일까? `docker build` 를 사용해보자.
이미지를 지금은 실행하고싶지 않고 만들고싶은것이니, `Dockerfile` 의 명령에 따라 이미지를 만들 수 있다.

`build` 명령으로 새 커스텀 이미지를 빌드하도록 도커에게 지시하자.
Dockerfile을 찾을 수 있는 곳을 알려주어야 하니 `docer build .` 로 이 명령을 실행하는 곳과 동일한 폴더에 존재함을 알려주자.![](https://velog.velcdn.com/images/chromeheartz/post/1e8af9f4-bb6c-47e6-b0fe-171bf9fb9b0b/image.png)

이제 이미지가 제대로 생성되는 것을 볼 수 있다.
`0aa8d6c86771` 이 ID로 docker run을 해보자. 컨테이너가 시작되며 완료되지 않고 계속 실행되는 것을 볼 수 있다. 그 이유는 실행한 명령이 노드 서버를 시작하기 때문에 완료되지않고 진행중인 프로세스가 된다.

그래서 컨테이너 또한 실행이 유지된다. 하지만 `localhost:80` 을 들어가게 되면 웹사이트가 표시가 되지 않는다.

#### 왜 작동하지 않을까?

일단 컨테이너를 `docker stop [CONTAINER_NAME]` 으로 정지 시켜주자.
커스텀 컨테이너에 대해 포트80에서 수신 대기 할 수 없는 이유는 무엇일까?
`EXPOSE 80` 명령이 있지만 실제로 이 명령은 도큐먼테이션 목적으로만 추가되었을 뿐 아무것도 하지 않는다.

실제로 컨테이너 포트를 노출시켜야 하지만, 그 외에 추가적으로 할 것이 있다.

> ✅ 컨테이너를 실행할 때 `-p` 플래그를 넣는것이다. 이는 `publish` 를 의미하는데, 이를 통해 도커에게 어떤 로컬 포트가 있는지 알려줄 수 있다.

로컬 머신의 어떤 포트가 이 내부의 도커 특정 포트에 액세스할 수 있는지 알려주는 것이다.
-p 다음 애플리케이션에 액세스하려는 로컬 포트를 지정한다 예를들어 3000 이라고하고 콜론을 추가하고 내부 도커 컨테이너 노출 포트를 넣는다(80)
![](https://velog.velcdn.com/images/chromeheartz/post/be68f85c-22ac-41ad-be56-6f35d818d9b1/image.png)

현재는 4000으로 진행함. `docker run -p 4000:80 [IMAGE_ID]`
로컬 포트 3000에 publish되었기 때문에 작동하게 된다.

이것이 첫 번재 커스텀 이미지이다. 디폴트 노드 이미지를 기반으로하여 자체 명령어 / 앱을 포함하고 있다. 기존 이미지인 노드 이미지를 기반으로 하는 커스텀 이미지가 있고 여기에 몇 가지 명령이 있다.

예를 들어, 코드를 복사하고 모든 종속성을 설치한다. 그런 후 `docker build` 명령으로 이미지를 만든 다음 `docker run` 명령으로 만든 이미지를 기반으로 컨테이너를 실행한다.
