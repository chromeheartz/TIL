## Docker Image & Container

### 04. Dockerfile을 사용하여 자체 이미지 빌드하기

---

### 📌 Dockerfile

커스텀 이미지를 빌드하려면 해당 폴더로 이동해야한다.
그리고 `Dockerfile` 이라는 파일을 만들어야 한다. 이것은 도커에 의해 식별되는 특별한 이름이다. 이러한 `Dockerfile` 작성에 대한 최상의 지원을 얻으려면 `VS code` 의 `extensions` 에 `Docker 확장 프로그램` 을 설치해주면 된다.

#### Dockerfile에 무엇을 넣으면 될까?

#### FROM

이 파일에는 자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령이 포함된다.
따라서 자체 이미지에 대한 설정 명령이 포함되어 있다.
일반적으로 `FROM` 으로 시작한다.
이를 통해 베이스 이미지에 내 이미지를 구축할 수 있다. 이론적으로 도커 이미지를 처음부터 빌드할 수 있지만, 코드에 필요한 기타도구와 같은 운영체제 레이어가 필요하다.

노드 이미지를 구축하기 위해 `FROM node` 를 작성한다.
내 시스템에 존재하거나 도커 허브상의 이미지 이름을 작성하면 된다.
실제로 이 도커 허브 이미지를 기반으로 컨테이너를 처음 실행했을 때 이 이미지가 로컬로 다운로드 및 캐시 되었기 때문에 실제로 이 이미지를 기반으로 컨테이너를 실행한 순간 로컬머신에도 존재하게 된다.

#### COPY

이렇게 하면 이미지를 가지고 오는 것으로 시작한 다음

> ✅ 도커에게 로컬 머신에 있는 파일이 이미지에 들어가야 하는지 알려준다.
> COPY 명령을 사용.
> 여기에서는 `COPY . .` 를 하면 된다.

기본적으로 두개의 경로를 지정하는데, 첫 번째 경로는 컨테이너의 외부, 이미지의 외부 경로이며 이미지로 복사되어야 할 파일이 있는곳이다.
📍**컨테이너 또한 이미지는 환경과 코드를 갖고 있으며, 거기에서 실행되는 것을 기억**

.를 넣으면 이는 도커에게 기본적으로 `Dockerfile` 이 포함된 동일한 폴더임을 알리는 것이다.
즉, 첫번쨰 . 는 이 프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야 한다고 알리는 것이고, 두 번째 . 는 그 파일을 저장해야 하는 이미지 내부의 경로이다.
모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는 로컬 머신의 파일 시스템에서 완전히 분리된 자체 내부 파일 시스템이 있다.
도커 컨테이너 내부에 숨겨져있는데, 실제로 루트 폴더 즉, 도커 컨테이너의 루트 엔트리를 사용하지 않고 사용자가 선택한 서브폴더를 사용하는 것이 좋다. `/app` 이라고 지정해보자.
`COPY . /app`

이제 도커 파일과 동일한 폴더에 있는 모든 파일과 거기에 있는 모든 하위 폴더가 컨테이너 내부의 app 폴더에 복사된다. 그리고 이 폴더가 존재하지 않는 경우에는 이미지와 컨테이너에 생성된다.

#### WORKDIR / RUN

이제 다음단계로 `npm install` 을 실행해야한다.
컨테이너 밖에서도 해야하는 일이고, 종속성을 설치하기 위해 실행해야한다.
이를 수행하려면 로컬 파일을 이미지에 복사한 후 이미지에서 명령을 `RUN` 하고싶다고 알릴 수 있다. 그러나 여기에 문제가 있는데, 디폴트로 이러한 모든 명령은 도커 컨테이너 및 이미지의 작업 디렉토리에서 실행된다.

그 작업디렉토리는 컨테이너 파일 시스템의 루트 폴더이다. 코드를 app 폴더에 복사하고 있기 때문에 npm install도 app 폴더내에서 실행시켜야 한다.
이럴때 `WORKDIR` 로 도커 컨테이너의 작업 디렉토리를 설정하면 된다.
`WORKDIR /app`

이것은 도커에게 모든 후속 명령이 그 폴더 내부에서 실행됨을 알리는 것이다.
이후에 `RUN npm install` 을 해주면 된다.
작업디렉토리를 /app 으로 설정했다는 사실을 감안하여 COPY를 `COPY . ./` 로 변경할 수 있다. `./` 는 도커 컨테이너의 현재 작업 디렉토리를 의미한다.
작업 디렉토리를 /app 으로 변경했기에 RUN / COPY도 해당 디렉토리를 기준으로 실행한다.
하지만 명시적으로 `COPY . /app` 으로도 할 수 있다.
이렇게 하는 것이 더 좋은 이유는 파일을 복사할 위치를 명확히 알 수 있고, 현재 작업 디렉토리가 무엇인지 보기 위해 추측하거나 살펴볼 필요가 없기 때문이다.

마지막 명령은 모든 작업이 완료되면 서버를 시작하라는 것이다.
`RUN node server.js` 라고 할 수도 있지만, 이것은 틀리다.
이 이미지가 빌드될 때마다 실행되기 때문이다.

여기에 있는 모든 것은 이미지 설정을 위한 도커에 대한 명령이다.

> ✅ 이미지는 컨테이너의 `템플릿` 이여야 한다.

이미지를 실행하는 것이 아니라, 이 이미지를 기반으로 컨테이너를 실행하는 것이다.
이미지를 기반으로 컨테이너를 시작하는 경우에만 서버를 시작하고 싶은것이다.
하나의 동일한 이미지에서 여러 컨테이너를 시작하면 노드 서버도 여러개 시작된다.
따라서 이를 위한 또 다른 명령이 있다.

#### CMD

`RUN` 과의 차이점은 이미지가 생성될 때 실행되지 않고, `이미지를 기반으로 컨테이너가 시작될 때` 실행된다는 것이다.
CMD는 배열을 전달한다. 명령을 두 개의 문자열로 분할하는데, 도커에게 이미지를 기반으로 컨테이너가 생성될때마다 그 컨테이너 내부에 있는 `node` 명령을 사용하여 `server.js` 를 실행하도록 지시한다.

하지만 이런식으로 실행하려고 하면 앱을 못보는데, 이 노드 웹서버는 `port 80` 에서 수신 대기하게 된다. 도커 컨테이너가 `격리` 되어있다고 여러번 언급했는데, 로컬 환경과 격리되어있고, 결과적으로 자체 내부 네트워크또한 있다.

따라서 컨테이너 내부의 노드 애플리케이션에서 포트 80 을 수신할 대 컨테이너는 그 포트를 로컬 머신에 노출하진 않는다. 따라서 컨테이너 내부에서만 무언가를 수신 대기 중이기 때문에 수신할 수 없는것이다.

#### EXPOSE

이 컨테이너가 시작될 때 로컬 시스템에 특정 포트를 노출하고 싶다는 것을 도커에게 알리는 `EXPOSE 80` 명령을 추가해야한다. 이 컨테이너를 실행할 로컬 머신에게.

```DOCKERFILE
FROM node

WORKDIR /app

COPY . ./

RUN npm install

EXPOSE 80

CMD ["node", "server.js"]
```
