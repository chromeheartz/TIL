## Docker Image & Container

### 02. 외부(사전 빌드된) 이미지의 사용 & 실행

---

### 📌 외부 이미지

컨테이너는 이미지를 기반으로 한다고 했었는데, 실제로 컨테이너를 실행할 수 있도록 이미지를 생성하고 가져오는 두 가지 방법이 있다.

- 이미 존재하는 이미지를 사용.
  동료가 이미 구축했거나, 매우 일반적이여서 미리 구축된 공식이미지나, 커뮤니티에서 공유한 이미지. `Docker Hub` 에서 찾아볼 수 있다.

![](https://velog.velcdn.com/images/chromeheartz/post/3bd710b6-eb97-457a-a0bd-cddb58de1272/image.png)

예를 들어 노드를 찾아보면 이렇게 나오는걸 볼 수 있다.
공식 노드 팀에서 `배포 / 생성 / 유지 / 관리` 를 하고, 이 과정 전반에 걸쳐 일반적으로 `Docker` 로 작업할 때 이러한 공식 이미지를 자주 사용한다.

터미널에 `docker run node` 를 실행하면 된다.
이렇게 하면 이 명령은 `Docker Hub` 에서 찾은 노드 이미지를 사용하여 이미지를 기반으로 하는 컨테이너를 생성한다.

> ✅ 컨테이너는 실제로 실행 중인 이미지 인스턴스이기 떄문.

이미지에는 환경 설정 코드가 포함되며, 이 경우 노드 이미지에는 노드 설치가 포함된다. 그런 다음 이미지를 실행하여 애플리케이션을 실행하거나 `노드 인터렉티브 쉘` 을 간단히 실행할 수 있다.

> `NodeJS` 는 `interactive mode` 를 제공하는데, 기본적인 노드 명령어인 `REPL` 을 사용할 수 있다.

명령어를 실행해보면, 로컬에서 이미지를 찾을 수 없어서 `Docker Hub` 에서 자동으로 가져온다. 이렇게 다운로드가 되면, 이미지를 기반으로 컨테이너를 실행할 수 있다.

명령을 입력하기 위해 `인터렉티브 쉘` 을 사용하여 노드를 실행할 수 있다. 기본적으로 컨테이너는 주변 환경과 격리되어 있으며 컨테이너 내부에서 실행중인 인터렉티브 쉘이 있다고해서, 이 `쉘` 이 사용자인 우리에게 노출된다는 의미는 아니다.

일단 `docker ps -a` 를 실행해서, 도커가 생성한 모든 컨테이너를 확인해보자.
![](https://velog.velcdn.com/images/chromeheartz/post/fd4120ea-5b53-4209-a0f3-644fa18523ff/image.png)
잘 만들어졌지만, 더이상 실행되지 않는다는 것을 알 수 있다.

컨테이너가 격리되어 실행되기 떄문에, 노드 이미지를 기반으로 하는 컨테이너로 실행했찌만 이것만으로는 별 의미가 없다.

> ✅ 노드에 의해 노출된 인터렉티브 쉘은 컨테이너에 의해 자동으로 노출되지 않기 때문에 `docekr run -it node` 로 `-it` 플래그를 사용해보자.

`-it` 플래그를 실행하게 되면 도커에게 컨테이너 내부에서 호스팅 머신으로 대화형 세션을 노출하고 싶다고 알리게 된다.

#### 중요한점

여기서 중요한 점은 노드가 생성된 컨테이너 내부에서 실행중이며 이 `-it` 플래그를 추가함으로써 터미널로 들어가 그 컨테이너 및 컨테이너에서 실행 중인 노드와 상호 작용할 수 있다는 것이다.
![](https://velog.velcdn.com/images/chromeheartz/post/5b4c53df-c900-4e7b-9f4c-6a95fc6ff15e/image.png)

그리고 이렇게 내가 설정한 컨테이너의 노드와 실제 로컬의 노드는 버전이 다르다는것을 볼 수 있고, 이는 상호 작용한 버전이 컨테이너 내부의 버전임을 의미한다.

노드 컨테이너를 실행하고, 상호작용하기 위해 시스템에 노드를 설치할 필요가 없다는 것이다.
이미지는 배후에서 컨테이너에 필요한 모든 논리와 모든 코드를 보관하는데 사용되며 `run` 명령을 사용하여 이미지의 인스턴스를 만든다. 그리고 이것은 이미지를 기반으로 하는 구체적인 컨테이너를 생성한다.

또한 2개의 컨테이너를 동시에 실행하려면 터미널을 연다음 docker run을 반복함으로써 동일한 이미지를 기반으로 하는 2개의 컨테이너가 동시에 실행될 수 있다.
