## 소개

### 08. 기능(Functional) 테스트 vs 유닛(Unit) 테스트
---------------------------------------------

### 📌 Unit Testing

- 유닛 테스트는 테스트를 `최대한 격리` 시킨다.
  - 그래서 함수나 컴포넌트를 테스트할 때 `의존성` 을 표시한다.
  - 즉, 다른 의존성이 있거나 컴포넌트가 의존하는 다른 함수가 있으면 `실제 버전 대신 테스트 버전` 을 사용한다.
  - 따라서 문제가 발생하거나 테스트에 실패시 생태계의 다른 어떤 것이 아니라 `테스트에 실패하게 만드는 특정 유닛` 이 문제인 것이다.
- `내부 테스트` 또한 진행한다.
  - 내부 테스트가 필요한 이유는 `격리 상태` 에서 컴포넌트를 테스트하면 때로는 `상태의 차이점` 에 관해서만 테스트하게 되기 때문이고, 이는 `앱 변경 사항` 을 확인하는 다른 컴포넌트가 없기 때문
  - 그래서 격리된 유닛에서 `실패를 쉽고 정확하게 파악` 할 수 있다.
  
> 테스트가 코드의 한 유닛에 격리되어 있기 때문에
테스트가 실패하면 `어디를 확인` 해야 하는지 정확하게 알 수 있다.

⭐️ 하지만 `사용자가 소프트웨어와 상호작용하는 방식` 과는 거리가 멀다. 테스트를 통과할 수 있다는 뜻
소프트웨어와 상호 작용하는 사용자가 실패하거나 그 반대로 사용자가 소프트웨어와 상호작용 하는데 문제가 없어도 `테스트에 실패` 할 수 있다.

⭐️ `리팩토링` 으로 실패할 가능성도 있다
`리팩토링` 은 동작을 변경하지 않고 소프트웨어 작성 방식을 변경하는 것으로 보통 `유닛 테스트` 로 소프트웨어가 어떻게 작성했는지 내부를 테스트 한다. 
이는 작성 방식을 변경하면 `동작이 변경되지 않아도` 테스트에 실패할 수 있음을 의미한다.
  

### 📌 Functional Testing

- 기능 테스트는 `테스트하는 특정 동작 / 유저플로우와 연관된 모든 단위` 를 포함한다.
  - 사용자가 소프트웨어와 상호 작용하는 방식과 밀접한 부분이 장점이다.
  - 즉, `테스트에 통과` 하면 사용자에게 문제가 없고, `테스트에 실패` 하면 사용자에게 문제가 발생할 가능성이 높다는 것을 의미
- 테스트가 `견고` 하다는 의미이기도 하다.
  - 코드 작성 방식을 리팩토링하면 동작이 `동일하게 유지` 되는 한 테스트도 통과하게 된다.
  - 단, `실패한 테스트` 를 `디버깅` 하기 어려운 점이 단점이다.
  
> `코드 테스트 / 유닛 테스트` 처럼 밀접하게 연결되어 있지 않아서 어떤 부분의 코드가 `테스트 실패의 원인` 인지 정확히 알 수 없다.

**✅ 전반적으로 `RTL` 은 기능 테스트의 장점이 단점을 보안한다고 생각해서 이 강의에서는 주로 기능 테스트 방식으로 테스트한다.**